---
layout: post
title: muduo源码探索 (十九)
categories: [muduo]
description: muduo源码探索-Poller
keywords: muduo, network, 网络
---

`Channel`类相对来说还是比较容易理解，就只有文件描述符和一些事件回调函数。所有的文件描述符都是非阻塞的，我们知道，非阻塞一般都是要和IO多路复用一起使用，`Poller`类就是负责这个。`Channel`将事件注册到`Poller`上，`Poller`统一监听，当有相应的事件到达，就去执行`Channel`注册事件时绑定的回调函数。实现IO多路复用的手段有很多，跨平台的有`select`和`poll`，但是Linux系统提供了一个`epoll`，毫无疑问，以其高性能成为首选。尽管如此，`Poller`类的实现还是稍微进行了一次抽象，底层的实现技术并不限制，只是一个接口，这也是整个工程中唯一使用继承的地方。

#### Poller

##### 1. 任务

- 实现IO多路复用的文件监听

##### 2. 实现

```c++
// Base class for IO multiplexing
// but it doesn't own the Channel objects
// 不负责管理Channel生存期
// Abstract class，负责定义高层接口
class Poller : noncopyable
{
public:
    using ChannelList = std::vector<Channel *>;

    Poller(EventLoop *loop);
    virtual ~Poller();  // 存在继承，所以是虚析构

    // Polls the IO events, must be called in the loop thead
    // pure virtual function
    virtual Timestamp poll(int timeoutMs, ChannelList *activeChannels) = 0;

    // change the interested IO events, must be called in the loop thread
    virtual void updateChannel(Channel *channel) = 0;

    // remove the channel, when it destructs, must be called in the loop thread
    virtual void removeChannel(Channel *channel) = 0;

    virtual bool hasChannel(Channel *channel) const;
    
    static Poller *newDefaultPoller(EventLoop *loop);

    void assertInLoopThread() const
    {
        ownerLoop_->assertInLoopThread();
    }

protected:
    // 便于查找
    using ChannelMap = std::map<int, Channel *>;
    ChannelMap channels_;
private:
    EventLoop *ownerLoop_;  // 归属EventLoop
};
```

很明显这是一个抽象类，因为有纯虚函数，只是负责定义接口，具体的实现，只要满足接口即可。纯虚函数有三个，是一定要被继承实现的，一个是`poll()`，就是返回事件触发的`Channel`列表，一个是`updateChannel()`，就更新`Channel`在`Poller`中事件坚挺的状态，还有一个`removeChannel()`，看名字就知道是取消`Channel`的监听。内部还维护了一个`map`，映射文件描述符到`Channel`，至于`EventLoop`指针，也是为了方便回调。

```c++
/**
 * just an abstract class
 */
Poller::Poller(EventLoop *loop)
    : ownerLoop_(loop)
{
}

// channels_(std::map)会自动析构
Poller::~Poller() = default;

bool Poller::hasChannel(Channel *channel) const
{
    assertInLoopThread();
    ChannelMap::const_iterator it = channels_.find(channel->fd());
    return it != channels_.end() && it->second == channel;
}
```

实现的部分也没有太多可说的，基本是默认的操作。

#### EpollPoller

##### 1. 任务

- 利用`epoll`实现`Poller`接口

##### 2. 实现

不考虑跨平台，这里我们只是用`epoll`实现。

```c++
// IO multiplexing with epoll(4)
// 继承抽象类，要实现接口
class EpollPoller : public Poller
{
public:
    EpollPoller(EventLoop *loop);
    virtual ~EpollPoller() override;
    // 抽象基类接口
    virtual Timestamp poll(int timeoutMs, ChannelList *activeChannels) override;
    virtual void updateChannel(Channel *channel) override;
    virtual void removeChannel(Channel *channel) override;

private:
    // 初始Event大小
    static const int kInitEventListSize = 16;

    static const char *operationToString(int op);

    // 辅助函数
    void fillActiveChannels(int numEvents, ChannelList *activeChannels) const;
    void update(int operation, Channel *channel);

    using EventList = std::vector<struct epoll_event>;

    int epollfd_;
    // 事件列表
    EventList events_;
};
```

看起来不是特别复杂，覆盖`Poller`的接口，两个辅助函数，一个`epoll`文件描述符和一个事件列表。

复杂的地方在于实现的细节，分开来看吧。

```c++
// 匿名命名空间，文件内部使用
namespace 
{
const int kNew = -1;
const int kAdded = 1;
const int kDeleted = 2;
}

EpollPoller::EpollPoller(EventLoop *loop)
    : Poller(loop),
    epollfd_(::epoll_create1(EPOLL_CLOEXEC)),   // 没必要非阻塞
    events_(kInitEventListSize)
{
    if (epollfd_ < 0)
    {
        LOG_SYSFATAL << "EpollPoller::EpollPoller";
    }
};

EpollPoller::~EpollPoller()
{
    ::close(epollfd_);
}
```

先在匿名空间定义三个`Channel`的状态，构造函数就是创建一个`epoll`文件描述符，使用的是`epoll_create1()`，这样就不用`fcntl`额外设置执行时关闭了，看的出调用了父类的构造函数，明显的继承。析构函数更简单，直接关闭文件描述符，事件列表会自动析构。

```c++
// 轮询出到达事件
Timestamp EpollPoller::poll(int timeoutMs, ChannelList *activeChannels)
{
    LOG_TRACE << "fd total count " << channels_.size();
    // 阻塞
    int numEvents = ::epoll_wait(epollfd_,
                            events_.data(),
                            static_cast<int>(events_.size()),
                            timeoutMs);
    
    int saveErrno = errno;
    Timestamp now(Timestamp::now());
    // 有事件到达
    if (numEvents > 0)
    {
        LOG_TRACE << numEvents << " events happeded";
        fillActiveChannels(numEvents, activeChannels);
        // events_数组扩容
        if (implicit_cast<size_t>(numEvents) == events_.size())
        {
            events_.resize(events_.size() * 2);
        }
    }
    else if (numEvents == 0)
    {
        LOG_TRACE << " nothing happeded";
    }
    else 
    {
        // error happens ,log uncommon ones
        if (saveErrno != EINTR)
        {
            errno = saveErrno;
            LOG_SYSERR << "EpollPoller::poll()";
        }
    }
    return now;
}
void EpollPoller::fillActiveChannels(int numEvents, 
                                    ChannelList *activeChannels) const
{
    assert(implicit_cast<size_t>(numEvents) <= events_.size());
    for (int i = 0; i < numEvents; ++i)
    {
        Channel *channel = static_cast<Channel *>(events_[i].data.ptr);
    #ifndef NDEBUG
        int fd = channel->fd();
        ChannelMap::const_iterator it = channels_.find(fd);
        assert(it != channels_.end());
        assert(it->second == channel);
    #endif
        // 设置事件到达
        channel->set_revents(events_[i].events);
        activeChannels->push_back(channel);
    }
}
```

这是整个IO多路复用的核心，内部是个`epoll_wait()`，在具体的使用的时候，这是被放在一个无限的循环中，反复的轮询，`epoll_wait()`会阻塞，直到有事件到来，当然这里设置了一个超时时刻，避免无限的阻塞。当事件到来的时候，就需要放入一个`Channel`列表中，如果事件很多，考虑事件监听列表扩容的事情，没有事件到来或者返回错误的情况比较容易解决。

因为`epoll_wait()`返回的是事件到来的个数，以及事件的列表，而且很关键的，我们在监听事件的`data`成员中放入的是一个`Channel`指针，这样获取的时候就很容易，直接遍历事件列表，设置`Channel`事件到来，放入`Channel`列表中，返回即可。

```c++
void EpollPoller::updateChannel(Channel *channel)
{
    // 必须在IO线程
    Poller::assertInLoopThread();
    const int index = channel->index();
    // 文件描述符->事件->状态
    LOG_TRACE << "fd = " << channel->fd() << " events = " << channel->events()
            << " index = " << index;
    // 新增、删除
    if (index == kNew || index == kDeleted)
    {
        // a new one, add with EPOLL_CTL_ADD
        int fd = channel->fd();
        if (index == kNew)
        {
            assert(channels_.find(fd) == channels_.end());
            // 放入map
            channels_[fd] = channel;
        }
        else 
        {
            assert(channels_.find(fd) != channels_.end());
            assert(channels_[fd] == channel);
        }
        // 更新状态和事件
        channel->set_index(kAdded);
        update(EPOLL_CTL_ADD, channel);
    }
    else 
    {
        // update existing one with EPOLL_CTL_MOD/DEL
        int fd = channel->fd(); (void)fd;
        assert(channels_.find(fd) != channels_.end());
        assert(channels_[fd] == channel);
        assert(index == kAdded);
        // 没有监听事件
        if (channel->isNoneEvent())
        {   
            // 删除事件
            update(EPOLL_CTL_DEL, channel);
            channel->set_index(kDeleted);
        }
        else 
        {
            // 修改事件
            update(EPOLL_CTL_MOD, channel);
        }
    }
}

void EpollPoller::removeChannel(Channel *channel)
{
    // 必须在IO线程内
    Poller::assertInLoopThread();
    int fd = channel->fd();
    LOG_TRACE << "fd = " << fd;

    assert(channels_.find(fd) != channels_.end());
    assert(channels_[fd] == channel);
    // 没有监听事件才能删除
    assert(channel->isNoneEvent());

    int index = channel->index();
    assert(index == kAdded || index == kDeleted);
    // 从map中移除
    size_t n = channels_.erase(fd); (void) n;
    assert(n == 1);

    if (index == kAdded)
    {
        // 更新事件，不再关注
        update(EPOLL_CTL_DEL, channel);
    }
    channel->set_index(kNew);
}
void EpollPoller::update(int operation, Channel *channel)
{
    struct epoll_event event;
    memZero(&event, sizeof(event));
    event.events = channel->events();
    event.data.ptr = channel;
    int fd = channel->fd();
    LOG_TRACE << "epoll_ctl op = " << operationToString(operation);
    
    // ERROR
    if (::epoll_ctl(epollfd_, operation, fd, &event) < 0)
    {
        if (operation == EPOLL_CTL_DEL)
        {
            LOG_SYSERR << "epoll_ctl op = " << operationToString(operation) << " fd = " << fd;
        }
        else 
        {
            LOG_SYSFATAL << "epoll_ctl op = " << operationToString(operation) << " fd = " << fd;
        }
    }
}
```

更新`Channel`和删除是比较复杂的。首先必须是要在IO线程内执行，通过获取`Channel`的状态，决定更新的效果，如果是新增，就直接放入`map`中，对应文件描述符到一个`Channel`，如果标记为删除，就什么都不做，因为是个伪删除，同时更新状态和事件。如果是已经添加到监听列表，如果此时`Channel`没有事件，就删除监听，否则更新监听的事件。

删除的话也是类似的，必须要`Channel`上没有监听的事件才可以移除。从`map`中移除，并且更新事件。

对于底层的`update()`函数，是很直接的，有操作和`Channel`，就是在底层的`epoll`上操作，通过`epoll_ctl()`实现，就是将`Channel`上的事件，提交给底层的`epoll`上，这样的更新才会有效果。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

第一次，应该也是最后一次使用继承。高层有个抽象类，定义一些接口，底层的实现就有很大的弹性。之前说过，整个网络库是基于事件的，继承关系很少，基本都是采用事件回调的方式。我们也要清楚，面向对象也是有它的一些优势，在使用的时候要抱着开放的态度，选择合适的技术使用。`Poller`类以及`EpollPoller`类，都是在`epoll`的基础上，实现了自己的功能，使用的时候，自然就很方便。

#### 参考：

- https://www.cnblogs.com/aspirant/p/9166944.html
- 《Linux多线程服务端编程》
- 《Linux/Unix系统编程手册》
