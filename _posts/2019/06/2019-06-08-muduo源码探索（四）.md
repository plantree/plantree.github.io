---
layout: post
title: muduo源码探索 (四)
categories: [muduo]
description: muduo源码探索-Exception
keywords: muduo, network, 网络
---

这次封装的类是`Exception`，异常类，目的是便于调试，是继承标准库中的`exception`基类，重写一些函数。虽然用的地方不太多（就我目前而言），但是整个实现还是挺有意思，尤其是`name mangle`和`demangle`，额外的，因为是多线程环境，在命名空间`CurrentThread`提供了一组线程局部设施，有变量，也有方法，方便调用。

#### Exception

##### 1. 任务

封装标准异常，同时提供函数调用栈的回溯信息。

##### 2. 实现

只有两个成员变量，异常名字和栈回溯的字符串表示，该字符串的生成函数被放入`CurrentThread`命名空间里，每个线程都有自己的一套方法和变量，互不影响。

```c++
class Exception : public std::exception 
{
public:
    Exception(string what);
    // 保证不抛出异常
    ~Exception() noexcept override = default;

    // default copy-ctor and assignment are ok
    
    const char *what() const noexcept override
    {
        return message_.c_str();
    }

    const char *stackTrace() const noexcept
    {
        return stack_.c_str();
    }

private:
    string message_;
    string stack_;
};
```

两点需要注意。

1. 虚函数重载中的C++11新的关键字`override`，是帮助编译器检查重载意图，因为有的时候，可能你想重载，但是参数写错，编译器会一声不吭的生成一个普通函数，调试的时候就比较麻烦。这里的`override`就是声明意图，如果没有重载，编译器会报错

2. `noexcept`意思是不会抛出异常，我们这里已经是在异常处理的过程中，一般情况下不会再跑出异常，否则就会出现异常内部嵌套异常的问题。《Effective Modern C++》条款14中说：

   > 只要函数不会发射异常，就为其加上noexcept关键字

   一般来说这样的代码更有可能被编译器优化，而且这个性质对于移动操作、swap、函数释放函数和析构函数最有价值 。

   多说一句，如果声明自己不会抛出异常的函数违背契约抛出了异常会被直接`terminate`。

#### CurrentThread

`CurrentThread`是个内部的命名空间，封装了几个线程局部变量，和几个获取栈回溯信息的方法。

##### 1. 任务

提供给个线程独立的变量，同时提供一组方法，获取人类易读的栈回溯信息。

##### 2. 实现

头文件里：

```c++
extern __thread int t_cachedTid;
extern __thread char t_tidString[32];   // to_String(tid)
extern __thread int t_tidStringLength;
extern __thread const char *t_threadName;   // name
```

`extern`是变量的声明，具体实现放在实现代码中。`__thread`是线程局部存储的关键字，头一回遇见，还查了《Linux/Unix系统编程手册》，这个技术的出现，是为了解决数据并发访问的问题，但凡有这个关键字的变量，每个线程都有一份专属的拷贝，各自访问自己的，自然就不存在`race condition`，相当方便。

```c++
// 只有在调用的时候才会缓存
inline int tid()
{
if (t_cachedTid == 0)
{
cachedTid();
}
return t_cachedTid;
}
```

对于线程专属`tid`而言，只会计算一次，就会立马缓存。而且这里是*懒惰求值*，如果没有调用的话，根本不会有真正的计算。这也是C++哲学中，“不必为不需要的东西付出代价”。

还有个函数，比较复杂`string stackTrace(bool demangle)`，是获取函数调用过程中的栈回溯信息，返回的值可以交给`Exception`构造函数。使用到的函数有：

1. `backtrace()`
2. `backtrace_symbols()`
3. `abi::__cxa_demangle`

第一个函数是获取栈回溯信息，第二个函数将获取到的栈回溯信息解析为可读形式，因为获取到的函数名字经过了`mangle`，第三个函数就是`demangle`。

其实通过`typeid(obj).name()`获取到的函数名字就是经过了`mangle`，不是给人类读的，是给编译器看的。《深入理解计算机系统》p454页说，这种方法是为了区分C++中的重载函数，交给链接器的函数名一定要是唯一标识。这里的`mangle`指的就是转换为`C++ ABI标识符`。

这里的`CurrentThread`只实现了部分函数，还有一部分在`Thread`类的实现里，后面再说。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

自己封装`Exception`，就是在已有功能的基础上进行扩充，增添自己的方法，比如这里增加的栈的回溯信息，启示就是充分理由现成的基础设施，重用复用，避免重新造轮子，细节深入也是要适可而止，刚刚好能解决问题就好。`CurrentThread`里头的线程局部存储，省却了共享变量的互斥访问问题，通过适度的暴露内部的方法，供给其他类调用。

#### 参考：

- https://www.cnblogs.com/BloodAndBone/p/7912179.html
- 《Effective Modern C++》
- 《深入理解计算机系统》

