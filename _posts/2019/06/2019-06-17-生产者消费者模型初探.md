---
layout: post
title: 生产者消费者模型初探
categories: [operating systems]
description: 生产者消费者模型初探
keywords: operating systems, practice, C
---

“生产者消费者”问题，在多线程编程中，算得上是一个非常经典的模型：生产者就是生产数据的线程，消费者就是消费数据的线程。如果生产者生产的很快，就必须等待消费者消费完，反之如果消费者消费的太快，就要等生产者的生产。

有篇文章说的很好，“生产者和消费者通过一个有限的容器解决强耦合问题，生产者和消费者彼此之间不直接通信，而是通过阻塞队列（Blocking Queue）“，生产者将生产的输入投入队列，消费者从队列中领取任务执行，阻塞队列本身会自动平衡两者的速度。

这个故事听起来很美好，但是真的要实现，还是有很多细节需要考量。

这里使用的手段，是通过一个互斥量以及两个条件变量。

#### Goal

- 实现一个简单的生产者消费者模型

#### Environment

- OS： ubuntu 18.04 (64 bit)
- Compiler: gcc 7.4.0

#### Step

#####　1. 实现

```c++
#define MAX 10

int buffer[MAX];
int count = 0;  // initailly, empty
int fill_ptr = 0;
int use_ptr = 0;
int loops = 100;

void put(int value)
{
    buffer[fill_ptr] = value;
    fill_ptr = (fill_ptr + 1) % MAX;
    ++count;
}

int get()
{
    int temp = buffer[use_ptr];
    use_ptr = (use_ptr + 1) % MAX;
    --count;
    return temp;
}
```

先设置一些全局变量，阻塞队列用数组表示，因为消费者和生产者都操作数组，但是两者的使用方式是不同的，还需要额外两个索引变量，标识当前的处理状态，至于`count`就是表示当前数组中的剩余任务。

```c++
// 两个条件变量
// 一个通知生产者，一个通知消费者
pthread_cond_t empty, fill;
pthread_mutex_t mutex;

void *producer(void *arg)
{
    int i;
    for (i = 0; i < loops; ++i)
    {
        pthread_mutex_lock(&mutex);
        // 队列满
        while (count == MAX)
        {
            pthread_cond_wait(&empty, &mutex);
        }
        assert(count < MAX);
        put(i);
        pthread_cond_signal(&fill);
        pthread_mutex_unlock(&mutex);
        printf("put: %d\n", i);
    }
}

void *consumer(void *arg)
{
    int i;
    for (i = 0; i < loops; ++i)
    {
        pthread_mutex_lock(&mutex);
        // 队列空
        while (count == 0)
        {
            pthread_cond_wait(&fill, &mutex);
        }
        assert(count > 0);
        int temp = get();
        pthread_cond_signal(&empty);
        pthread_mutex_unlock(&mutex);
        printf("%s: %d\n", (char *)arg, temp);
    }
}
```

整体来看，生产者和消费者函数，内部都有一个循环，不停的生产或者消费任务，因为两个（或许更多个）线程共享同一份变量，自然需要同步的机制，互斥量是必要的，这里还需要条件变量，因为我们需要监控阻塞队列的状态变化，然后将这个信息通知其他变量，这里的就是当生产者放入数据的时候，就应该通知消费者来消费，反之，当消费者消费了任务，队列不满的时候，就应该通知生产者继续生产。否则，如果队列满，生产者应该睡眠等待队列不满，如果队列为空，消费者也应该等待。那么这里为什么需要两个条件变量？因为我们需要监视的，是两个状态变化：队列为空，以及队列满。如果只有一个条件变量，那么状态就只是阻塞队列里的数据发生了变化，至于是唤醒消费者，还是生产者，是很不明确的，也会产生问题。

```
pthread_mutex_lock(&mutex);
while (status == true)
{
    pthread_cond_wait(&cond, &mutex);
}
do_something...
pthread_cond_signal(&cond);
pthread_mutex_unlock(&mutex);
```

这是核心的代码，信息量很大。都知道条件变量需要和互斥量一起使用，因为这两者的任务是不同的，互斥量提供的是互斥访问，而条件变量是将某个状态变化通知其他线程。那这个的互斥量保护的是什么？是条件变量所监视状态发生所在的那个变量，如果没有互斥量的保护，那么状态变化后在通知其他线程的间隙，就有可能被更改，造成问题。为什么使用循环而不是if？两个原因：

1. `pthread_cond_wait()`返回的时候，判断条件不一定成立，因为其他线程可能会醒来，改变共享变量的状态，因此需要再次的判断
2. 可能会发生虚假唤醒的情况

因此在实际中，最好用条件变量”表征可能性而非确定性“。

上面的代码中，解锁互斥量是在条件变量`signal`之后，也有一些实现是先解锁，然后`signal`。

man给出的答案是：

> The *pthread_cond_broadcast*() or *pthread_cond_signal*() functions may be called by a thread whether or not it currently owns the mutex that
> threads calling *pthread_cond_wait*() or *pthread_cond_timedwait*() have associated with the condition variable during their waits; however, if
> predictable scheduling behavior is required, then that mutex shall be locked by the thread calling *pthread_cond_broadcast*() or
> *pthread_cond_signal*().

如果需要调度行为可预测，那么就应该**在加锁的情况下调用signal**。

#### 2. 测试结果

测试结果如下：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190617163121.png)

相关代码都在这里[Github](https://github.com/plantree/Practice)

#### Thinking：

看似简单的问题，需要考虑的细节很多。也许很多人说，细节不重要，只要主要逻辑没问题，就够了，也许有些时候是可以取得正确的结果，但是是有着偶然性的。在理解和学习一些概念的时候，当然是要深入了解到底层，把握住细节，知道哪些地方是有可能出问题，在使用的时候，自然心里就有把握。不能陷入无穷的细节中，忘记了主要目的；也不能忽视细节，因为问题往往就出现在细节上。生产者消费者模型，对于理解多线程之间的同步，以及任务的调度，清晰、直接，值得学习。

#### Reference：

- https://www.infoq.cn/article/producers-and-consumers-mode

- https://blog.csdn.net/gqtcgq/article/details/52301749

- 《Linux/Unix系统编程手册》

  

  