---
layout: post
title: 智能指针的简单实现
categories: [C++]
description: 智能指针的简单实现
keywords: C++, practice
---

C++11中的智能指针，的确令人惊艳，通过对原始裸指针封装，简化内存资源管理，用户只管使用，该释放的时候资源会被自动释放，越来越像是`Garbage Collection`，而且使用上的一些习惯，比如取引用，比如箭头运算符，与原始指针的接口一致。简单、清晰、一致，没有理由再去使用原始的指针，那样不仅会增添资源管理的复杂性，而且隐含着一些常见错误，比如忘记释放`new`出来的内存造成内存泄露，比如引用已经失效的地址。

自然，使用归使用，按照侯捷老师的说法，只有对底层的实现有所了解，使用的时候才能

> 心中自有丘壑

无疑会更加的得心应手。标准库目前自己尚在使用阶段，用的不是特别娴熟，因此打算熟悉一段时间，摸清楚大体脉络之后再去研究一下源码，故而这里的一些实现，应该只是算是玩具级的代码，从博客和一些书籍里汲取的灵感。

智能指针的，其实就是C++中常见的`RAII`手法，借助对象管理资源，这个思路很常见。而且引用计数也不是新的发明，但是能将这些平淡无奇的，无论是技术也好，观念也罢，实现为一个趁手的工具，也不是所有人都能想出来的。

标准库有这么两个模板类，`shared_ptr`和`unqiue_ptr`。

`shared_ptr`望文生义，有着共享的意思，多个对象共享一份底层资源，避免拷贝，而且节约空间，当然也不是没有代价，就是资源的管理会变得异常复杂，什么时候初始化，什么时候析构资源，不同对象的生命期也不同，如果底层资源提前析构，问题自然就会很大，而如果迟迟的不释放，也会耗费宝贵的内存资源。

`unique_ptr`是取代之前的`auto_ptr`，本质上更像是原始指针，底层资源是独享的，但是这个智能指针不能拷贝和复制，但是可以拷贝一个即将被销毁的对象（移动语义）。

以上是大体背景。

#### Goal

- 引用计数模型实现`SmartPointer`
- 封装`UniquePtr`，并实现移动语义
- 借助`Catch`完成测试

#### Environment

- OS： ubuntu 18.04 (64 bit)
- Compiler: g++ 7.3.0

#### Step

#### 1. SmartPointer

`SmartPointer`底层是个引用计数模型，这个模型说来其实并不复杂，就是给底层资源做一个簿记工作：记录有多少对象在使用它。如果发现没有人用了，就将资源释放，原理比较简单。

可以发现，底层资源的存放应该是和引用计数绑定在一起的，实现的时候实现为一个内部类，供更高层的类使用。

类图大体如下：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190608184322.png)

`Counter`内部有个指针和引用技术，构造函数和析构函数都很简单。

```c++
template <typename U = T> 
struct Counter
{
    Counter() = default;
    Counter(T *p) : _ptr(p), _cnt(1)
    {
    }
    ~Counter() noexcept
    {
        delete _ptr;
    }

    T *_ptr = nullptr;
    int _cnt = 0;
};
```

当传入一个指针的时候，引用计数正式开始。

对于`SmartPointer`而言，内部只有一个`Counter`成员变量，表示共享的底层资源，构造函数很直接，就是构造`Counter`指针。

```c++
explicit SmartPointer() : ptr_counter(new Counter<>())
{
}
explicit SmartPointer(T *p) : ptr_counter(new Counter<>(p))
{
}
```

比较复杂的，是拷贝构造，以及赋值操作，和类的析构，因为涉及到了底层资源的共享问题。

```c++
// 拷贝构造
SmartPointer(const SmartPointer &sp)
{
    ptr_counter = sp.ptr_counter;
    ++ptr_counter->_cnt;
}
// 赋值
SmartPointer &operator=(const SmartPointer &sp)
{
    // 可以自动处理自赋值的情况
    ++sp.ptr_counter->_cnt;
    if (ptr_counter->_cnt == 0 || --ptr_counter->_cnt == 0)
    {
        delete ptr_counter;
        ptr_counter = nullptr;
    }
    ptr_counter = sp.ptr_counter;
    return *this;
}
```

拷贝构造就直接共享指针，记得引用计数加一。

对于赋值操作而言，首先左边对象内部资源引用计数减1，这时候就要判断，底层资源是否需要释放，右边对象引用计数加1，同时要考虑到自赋值的问题。

析构函数也很清楚：

```c++
~SmartPointer()
{
    if (--ptr_counter->_cnt == 0)
    {
    	delete ptr_counter;
    }
}
```

一个简单的引用计数模型实现智能指针就呼之欲出了。另外可以额外增加一些成员函数辅助操作，核心逻辑都在上面，发现其实就是维护好引用计数，何时增加，何时减少，以及何时释放资源。

#### 2. UniquePointer

`UniquePointer`相对就简单一些，就是利用`RAII`技术对于裸指针封装，借助对象的构造、析构过程管理资源，而且额外实现了一些辅助函数。

刚开始实现了拷贝语义，后来才发现标准库里的`std::unique_ptr`是移动语义的，不过修改起来也并不复杂。

类图如下：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190608190339.png)

移动语义实现并不复杂，就只是指针变量的赋值而已：

```c++
// move constructor
UniquePointer(UniquePointer &&rhs) noexcept
{
    std::cout << "move constructor" << std::endl;
    if (this != &rhs)
    {
        _ptr = rhs._ptr;
        rhs._ptr = nullptr;
    }
}
UniquePointer &operator=(UniquePointer &&rhs) noexcept
{
    std::cout << "move assignment" << std::endl;
    if (this != &rhs)
    {
        _ptr = rhs._ptr;
        rhs._ptr = nullptr;
    }
    return *this;
}
```

额外按照`std::unique_ptr`的接口实现资源的手动释放和重置函数

```c++
T *release() 
{
    T *old_ptr = _ptr;
    _ptr = nullptr;
    return old_ptr;
}
// void reset()隐含
void reset(T *ptr = nullptr)
{
    if (_ptr != ptr)
    {
        delete _ptr;
        _ptr = ptr;
    }
}
```

#### 3. 测试结果

测试结果如下：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190608190733.png)

相关代码都在这里[Github](https://github.com/plantree/Practice)

#### Thinking：

实事求是，实现的很简单，标准库源码也没有看，`UniquePointer`的实现仿照《More Effective C++》书后的`auto_ptr`实现，引用计数模型也有参考。现在大体明白，有些事情，看上去比较复杂，不过也许原理很简单，但这并不是说真的实现一个工业级强度的智能指针是一件容易的事，照着自己目前的水平，尝试做一些有些难度，但是尚海能接受的事情。就像我现在，如果上来就让我仿照标准库来写，恐怕会很痛苦：因为使用尚且做不到很熟练，直接看源码就相当于跳级，其实得不偿失。现在打算先把《C++标准库（第二版）》看一遍，伴随学习的深入，再去了解更底层的实现。起步的时候，步子不能迈太大。

#### Reference：

- http://brucechen7.github.io/

- 《Effective Modern C++》

- 《More Effective C++》

- https://blog.csdn.net/k346k346/article/details/59582926

  