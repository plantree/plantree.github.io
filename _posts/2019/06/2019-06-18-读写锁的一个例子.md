---
layout: post
title: 读写锁的一个例子
categories: [operating systems]
description: 读写锁的一个例子
keywords: operating systems, practice, C
---

平常在写多线程程序的时候，一般互斥锁用的比较多，而且用法也很精简。线程安全的基本原则，就是要么没有共享变量，要么共享变量是只读操作，那么就不会造成并发访问的不良后果。应该说只是在某些特定的应用场景下，读写锁会带来性能上的提升，比如说很频繁的读，以及十分少量的写，反复的使用互斥锁的确没太必要，毕竟共享读是没有问题的。不过一般时候还是使用互斥锁。

读写锁（`read-write-lock`）和互斥量很像，但是允许更大的并行度，锁的状态有三种：读者加锁、写者加锁、不加锁。读者模式可以反复加锁，没有问题，但是写者模式，就是互斥的，固定时间只能有一个写者，但是可以同时存在多个读者。因此适用的场景也很独特：读操作占据所有操作的大部分。

后面会看到，如果处理不好，有时候会造成饥饿。

代码参考[博客](https://cloud.tencent.com/developer/article/1021461)

#### Goal

- 实现一个读者优先、和写者优先的读写锁

#### Environment

- OS： ubuntu 18.04 (64 bit)
- Compiler: gcc 7.4.0

#### Step

#####　1. 实现

实现了两种不同优先级的读写锁，先看第一种，读优先。

```c++
// version 1
// 读优先
class rwlock1
{
public:
    rwlock1() : read_cnt(0)
    {
        pthread_mutex_init(&read_mutex, nullptr);
        pthread_mutex_init(&write_mutex, nullptr);
    }
    ~rwlock1()
    {
        pthread_mutex_destroy(&read_mutex);
        pthread_mutex_destroy(&write_mutex);
    }

    // read lock
    // 可多次加锁
    void ReadLock()
    {
        pthread_mutex_lock(&read_mutex);
        if (++read_cnt == 1)
        {
            pthread_mutex_lock(&write_mutex);
        }
        pthread_mutex_unlock(&read_mutex);
    }
    void ReadUnlock()
    {
        pthread_mutex_lock(&read_mutex);
        if (--read_cnt == 0)
        {
            pthread_mutex_unlock(&write_mutex);
        }
        pthread_mutex_unlock(&read_mutex);
    }

    // write lock
    void WriteLock()
    {
        pthread_mutex_lock(&write_mutex);
    }
    void WriteUnlock()
    {
        pthread_mutex_unlock(&write_mutex);
    }
private:
    pthread_mutex_t read_mutex;
    pthread_mutex_t write_mutex;
    int read_cnt;   // 读锁个数
};
```

仅仅使用了两个互斥量，一个负责给读者加锁，一个负责给写者加锁，额外还有一个`read_cnt`，记录读者的个数，因为读者是可以并发读的。写者加锁比较简单，就是直接使用互斥量，但是读者则不同，在加锁的时候，首先把`read_mutex`锁住，这时候判断`++read_cnt`是否为1，这个判断的意思是，当有一个读者的时候，写者就不应该获取锁，否则在临界区一个线程读，一个线程写，数据不一致就不可避免，因此这个时候要把`write_mutex`锁住，最后把`read_mutex`释放，这样读者可以多次获取锁。读者解锁的时候，也需要判断这时候是不是最后一个读者要离开，如果是，那么就可以把`write_mutex`解锁，这时候阻塞在等待这个锁的线程就可以执行写的操作了。

这是一个读者优先的例子，如果不断地有读者到来，那么写者就无止境的阻塞在等待锁，造成饥饿。

下面看第二个例子，写者优先，明显复杂很多。

```c++
// version 2
// 写优先
class rwlock2
{
public:
    rwlock2() 
    : ref_count(0),
    read_waiters(0),
    write_waiters(0)
    {
        pthread_mutex_init(&rw_mutex, nullptr);
        pthread_cond_init(&read_cond, nullptr);
        pthread_cond_init(&write_cond, nullptr);
    }
    ~rwlock2()
    {
        pthread_mutex_destroy(&rw_mutex);
        pthread_cond_destroy(&read_cond);
        pthread_cond_destroy(&write_cond);
    }
    void ReadLock()
    {
        pthread_mutex_lock(&rw_mutex);
        while (ref_count < 0)
        {
            ++read_waiters; // 多了个读者等待
            pthread_cond_wait(&read_cond, &rw_mutex);
            --read_waiters; // 一个读者醒来，拿到了锁
        }
        ++ref_count;
        pthread_mutex_unlock(&rw_mutex);
    }
    void WriteLock()
    {
        pthread_mutex_lock(&rw_mutex);
        // 与读者、写者同时互斥
        while (ref_count != 0)
        {
            ++write_waiters;
            pthread_cond_wait(&write_cond, &rw_mutex);
            --write_waiters;
        }
        --ref_count;
        pthread_mutex_unlock(&rw_mutex);
    }
    void Unlock()
    {
        pthread_mutex_lock(&rw_mutex);
        // 写者
        if (ref_count == -1)
        {
            ref_count = 0;
        }
        else 
        {
            // 读者
            --ref_count;
        }
        if (ref_count == 0)
        {
            if (write_waiters > 0)
            {
                pthread_cond_signal(&write_cond);
            }
            else if (read_waiters > 0)
            {
                pthread_cond_signal(&read_cond);
            }
        }
        pthread_mutex_unlock(&rw_mutex);
    }
    // 非阻塞
    int tryReadLock()
    {
        int ret = 0;
        pthread_mutex_lock(&rw_mutex);
        if (ref_count < 0 || write_waiters > 0)
        {
            ret = -1;
        }
        else 
        {
            ++ref_count;
        }
        pthread_mutex_unlock(&rw_mutex);
        return ret;
    }
    int tryWriteLock()
    {
        int ret = 0;
        pthread_mutex_lock(&rw_mutex);
        // 有读者或者有写者
        if (ref_count != 0)
        {
            ret = -1;
        }
        else 
        {
            ref_count = -1;
        }
        pthread_mutex_unlock(&rw_mutex);
        return ret;
    }
private:
    pthread_mutex_t rw_mutex;
    int ref_count;      // -1表示有写者，0表示无锁，正数表示读者个数
    int read_waiters;   // 读等待
    int write_waiters;  // 写等待
    pthread_cond_t read_cond;
    pthread_cond_t write_cond;
};
```

写者优先的意思，就是一旦有写者到来，无论是否有读者等待，优先选择写者。这里使用到了一个互斥量，两个条件变量，一个通知读者，一个通知写者，还有个引用技术，表征目前锁的状态，-1说明有一个写者，0的话说明锁是空闲的，正数表明读者的数量。至于`read_waiters`和`write_waiters`表示当前正在等待的读者和写者的数量，也就是想获取锁，但是因为一些原因拿不到，就要等待。

读者加锁，首先要判断这个时候是不是有写者占着，有的话就得等待，同时递增`read_waiters`，没有的话就可以把`ref_count`引用计数加1；写者加锁，就要判断目前是不是锁是空着的，不为空就要等待，否则就可以让`ref_count=-1`，说明目前是写者占据的状态。解锁的过程只有一个，判断当前锁的状态，写者的话，释放，否则的话，减少一个读者的数量。如果此刻锁是空闲的，那么查看是否有写者等待，有的话，唤醒此刻等待的写者线程，否则唤醒读者线程。

额外还写了两个非阻塞获取锁。

非阻塞获取读锁，首先就看是否有写者，以及是否有等待着的写者，有的话返回`-1`，否则获取锁，同时递增读者数量。

非阻塞获取写锁，要判断此刻锁是否空着，是的话就拿到，否则就要返回`-1`。

#### 2. 测试结果

这次暂时没有写测试，下次补上。

相关代码都在这里[Github](https://github.com/plantree/Practice)

#### Thinking：

陈硕老师在《Linux多线程服务端编程》书中并不建议使用读写锁，一来比较容易犯错误，二来效率并不一定比互斥量来的更高。这里用简单的互斥量和条件变量，就可以模拟读写锁的基本功能。或许这在某一方面说明，处理多线程编程，互斥量和条件变量的组合，基本就可以解决所有的问题。读写锁的特点和应用场景还是应该了解的，知己知彼，才能做出更好的选择。

#### Reference：

- https://cloud.tencent.com/developer/article/1021461

- 《Unix环境高级编程》

  

  