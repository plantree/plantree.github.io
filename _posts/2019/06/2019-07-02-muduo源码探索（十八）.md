---
layout: post
title: muduo源码探索 (十八)
categories: [muduo]
description: muduo源码探索-Channel
keywords: muduo, network, 网络
---

上次实现的`TimerQueue`，涉及到了一些类，比如`Channel`、`Poller`和`EventLoop`，现在补充着把前面的两个先说了。

`Channel`这个类，是对于文件描述符的包装，设置了加诸在`fd`上的各类事件，读、写、错误等等，文件描述符可以是socket、eventfd、timerfd或者signalfd，都被纳入到统一的`Channel`框架内。内部的成员变量和函数很多，其实大多都长得类似，`tie()`方法比较特别，后面会再次提到，主要是为了管理生命期的问题。`events_`是为了后面的`Poller`，记录的是该`Channel`需要监听的事件。它的内部也有一个`EventLoop`，原因也是为了使用回调。

#### Channel

##### 1. 任务

- 封装文件描述符，并设置、记录回调函数和监听事件

##### 2. 实现

内部的成员还是挺多的，不过大多写起来很类似。

```c++

// A selectbale IO channel
// This class doesn't own the file descriptor.
// who opened it, who should close it
// The file descriptor could be a socket, 
// an eventfd, a timerfd, or a signalfd
// 对于事件的统一封装
class Channel : noncopyable
{
public:
    // 回调函数
    using EventCallback = std::function<void()>;
    using ReadEventCallback = std::function<void(Timestamp)>;

    Channel(EventLoop *loop, int fd);
    ~Channel();

    void handleEvent(Timestamp receiveTime);
    // 设置读回调
    void setReadCallback(ReadEventCallback cb)
    {
        readCallback_ = std::move(cb);
    }
    // 设置写回调
    void setWriteCallback(EventCallback cb)
    {
        writeCallback_ = std::move(cb);
    }
    // 设置关闭时回调
    void setCloseCallback(EventCallback cb)
    {
        closeCallback_ = std::move(cb);
    }
    // 设置错误回调
    void setErrorCallback(EventCallback cb)
    {
        errorCallback_ = std::move(cb);
    }

    // FIXME
    // Tie this channel to the owner object managed by shared_ptr,
    // prevent the owner object being destroyed in handleEvent
    // 主要是为了控制生存期，所属对象的生存期比Channel短
    // 会造成一些意外情况
    void tie(const std::shared_ptr<void> &);

    int fd() const 
    {
        return fd_;
    }
    int events() const 
    {
        return events_;
    }
    void set_revents(int revt)
    {
        revents_ = revt;    // used by pollers
    }
    int revents() const 
    {
        return revents_;
    }
    bool isNoneEvent() const 
    {
        return events_ == kNoneEvent;
    }

    void enableReading()
    {
        events_ |= kReadEvent;
        update();   // calling Poller
    }
    void disableReading()
    {
        events_ &= ~kReadEvent;
        update();
    }
    void enableWriting()
    {
        events_ |= kWriteEvent;
        update();
    }
    void disbaleWriting()
    {
        events_ &= ~kWriteEvent;
        update();
    }
    void disableAll()
    {
        events_ = kNoneEvent;
        update();
    }
    bool isReading() const 
    {
        return events_ & kReadEvent;
    }
    bool isWriting() const 
    {
        return events_ & kWriteEvent;
    }

    // for poller
    int index() const 
    {
        return index_;
    }
    void set_index(int idx)
    {
        index_ = idx;
    }

    // for debug
    string reventsToString() const;
    string eventsToString() const;

    // 挂起
    void doNotLogHup()
    {
        logHup_ = false;
    }

    // 归属EventLoop(有且只有一个)
    EventLoop *ownerLoop()
    {
        return loop_;
    }
    void remove();

private:
    static string eventsToString(int fd, int event);

    void update();
    void handleEventWithGuard(Timestamp receiveTime);

    static const int kNoneEvent;    // 无事件
    static const int kReadEvent;    // 读事件
    static const int kWriteEvent;   // 写事件

    EventLoop *loop_;   // channel所属EventLoop
    const int fd_;      // 文件描述符
    int events_;        // 关注的事件
    int revents_;       // poller返回的事件
    int index_;         // 在poller数组中的状态
    bool logHup_;       // for POLLHUP

    std::weak_ptr<void> tie_;
    bool tied_;
    bool eventHandling_;    // 是否处于处理事件中
    bool addedToLoop_;
    
    ReadEventCallback readCallback_;
    EventCallback writeCallback_;
    EventCallback closeCallback_;
    EventCallback errorCallback_;
};
```

构造函数和析构函数也很直接，析构函数几乎什么都没有做，就是个平凡的析构函数，多了一些判断，因为`Channel`的生命周期会收到其他类的影响，不能轻易地死亡。

```c++
Channel::Channel(EventLoop *loop, int fd)
    : loop_(loop),
    fd_(fd),
    events_(0),
    revents_(0),
    index_(-1), // kNew
    logHup_(true),
    tied_(false),
    eventHandling_(false),
    addedToLoop_(false)
{
}

Channel::~Channel()
{
    assert(!eventHandling_);
    assert(!addedToLoop_);
    if (loop_->isInLoopThread())
    {
        assert(!loop_->hasChannel(this));
    }
}
```

处理回调事件很有讲究，

```c++
// FIXME
// 确保对象还活着，否则事件将不会被处理
void Channel::handleEvent(Timestamp receiveTime)
{
    std::shared_ptr<void> guard;
    // 弱引用
    if (tied_)
    {
        guard = tie_.lock();
        if (guard)
        {
            // 保证对象还活着
            handleEventWithGuard(receiveTime);
        }
    }
    else 
    {
        handleEventWithGuard(receiveTime);
    }
}

void Channel::handleEventWithGuard(Timestamp receiveTime)
{
    // 正在处理事件
    eventHandling_ = true;
    LOG_TRACE << reventsToString();
    // the peer closed its end of the channel
    // 挂起且不可读
    if ((revents_ & POLLHUP) && !(revents_ & POLLIN))
    {
        if (logHup_)
        {
            LOG_WARN << "fd = " << fd_ << " Channle::handle_event() POLLHUP";
        }
        if (closeCallback_)
        {
            closeCallback_();
        }
    }

    if (revents_ & POLLNVAL)    // invalid request
    {
        LOG_WARN << "fd = " << fd_ << " Channel::handle_event() POLLNVAL";
    }

    if (revents_ & (POLLERR | POLLNVAL))
    {
        if (errorCallback_)
        {
            errorCallback_();
        }
    }

    // 读事件
    if (revents_ & (POLLIN | POLLPRI | POLLRDHUP))
    {
        if (readCallback_)
        {
            readCallback_(receiveTime);
        }
    }

    // 写事件
    if (revents_ & POLLOUT)
    {
        if (writeCallback_)
        {
            writeCallback_();
        }
    }
    eventHandling_ = false;
}
```

因为生存期的原因，`Channel`在响应回调的时候，一定要确保原来的对象还活着，否则就什么都不做，这就是`tie()`和弱引用在这里的作用，在不增加原有对象的生存期的前提下，可以判断对象是否还活着（`weak_ptr.lock()`），如果还活着，就可以执行事件响应。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

`Channel`是个特殊的类，每个文件描述符对应一个，但是自己几乎没有什么资源需要管理（资源管理的核心，就是谁申请，谁释放）。`Channel`是个底层的类，简单包裹文件描述符，所有的事件，无论是注册，还是响应，都是透过这个类进行的，可以说是事件管理的原子类。一方面减少了复杂性，另一方面是一个简单的抽象，所有的文件描述符都不见了，我们见到的，就是一个个`Channel`。

#### 参考：

- 《Linux多线程服务端编程》
- 《Linux/Unix系统编程手册》
