---
layout: post
title: muduo源码探索 (一)
categories: [muduo]
description: muduo源码探索-Timestamp
keywords: muduo, network, 网络
---

`muduo`的代码和《Linux多线程服务端编程》都看过一遍，整体的框架有了比较宏观的把握，这也是当初打算学习这些内容时候的策略：先整体了解，细节逐步深入。

趁着源码过了一遍，而且无论是测试用例还是一些exmple都编译通过，结合近段时间看《Linux/Unix系统编程手册》获取到的一些底层操作系统的理解，因此打算从头开始，再梳理一遍。

整体的架构重新分配了一下，原有代码分割为`base`和`net`两个库，我打算把`log`模块抽取出来，单独做一个库。至于`http`这些更高层的库，也是单独罗列，互相之间不受影响，因为`muduo`本身是在`TCP`的基础上实现的一个高性能的网络库，至于想要用它做什么就因人而异。其实源码里头有些类并没有完全用到，但是借此了解一些C++设计方面的技巧，以及在处理网络传输中的各种事件时的各种考量，是很有必要的。

#### Timestamp

##### 1. 任务

先从`base`库开始。

第一个类是`Timstamp`，表示一个日历时间，准确的说是自1970年1月1日零点以来经过的事件。通过封装成一个类，可以简化之后的关于时间上要进行的额外处理。

之前再看《C++沉思录》的时候，作者说，C++的思维，就是

> 用类去表示概念

这个说法在`Timestamp`类上也成立。从名字也能看出来，这是个*时间戳*，内部其实就只是一个`int64_t`的整数，表示UTC时间，单位是毫秒，这也是为什么作者建议调用的时候传值即可，可以借助寄存器，而且拷贝的耗散并不大。

##### 2. 实现

这个类的构造函数实在寻常，无非就是传入一个整型的值，一般是通过调用`Timestamp::now()`这一静态成员函数实现（直接通过类名访问），该函数的内部是借助`gettimeofday()`函数实现，代码不难：

```c++
Timestamp Timestamp::now()
{
    struct timeval tv;
    // 获取微秒级精度
    gettimeofday(&tv, nullptr);
    int64_t seconds = tv.tv_sec;
    return Timestamp(seconds * kMicroSecondsPerSecond + tv.tv_usec);
}
```

在栈上定义一个临时的`timval`结构存储获取到的时间戳，按照操作系统可以达到微秒精度。

既然有了时间戳，我们可以做的事情就很多了，可以比较大小，可以计算时间差值，这个都有实现。

```c++
inline bool operator<(Timestamp lhs, Timestamp rhs)
{
    return lhs.microSecondsSinceEpoch() < rhs.microSecondsSinceEpoch();
}

inline bool operator==(Timestamp lhs, Timestamp rhs) 
{
    return lhs.microSecondsSinceEpoch() == rhs.microSecondsSinceEpoch();
}

// 获取时间差，单位(秒)
inline double timeDifference(Timestamp high, Timestamp low)
{
    int64_t diff = high.microSecondsSinceEpoch() - low.microSecondsSinceEpoch();
    return static_cast<double>(diff) / Timestamp::kMicroSecondsPerSecond;
}
```

其实更重要，是要通过人类可以理解的方式表达时间，这就涉及到时间的转换，从时间戳转换为比如年月日这些时间格式，代码里通过实现`Timestamp::toFormattedString()`完成，核心的是`localtime_r`函数调用，这个函数可以帮助我们将日历时间转换为当地时区的可读格式，而且可以很明显的看出来这是线程可重入版本（被多个线程调用时，不会引用任何共享数据）。因为本身我们做的网络库是基于Linux的多线程应用，当然要尽一切可能减少数据竞争（race condition），对于`localtime`而言，返回的数据是在静态缓冲区上，多次调用会被覆盖，而这里我们通过定义临时对象，因为是在栈上，因此保证获取到的数据是私有的，不会被其他线程看到。

```c++
string Timestamp::toFormattedString(bool showMicroseconds) const 
{
    char buf[64] = {0};
    time_t seconds = static_cast<time_t>(microSecondsSinceEpoch_ / kMicroSecondsPerSecond);
    // 分解时间
    struct tm tm_time;
    // 可重入,线程安全,将时间戳转换为当地日期
    localtime_r(&seconds, &tm_time);

    if (showMicroseconds) 
    {
        int microSeconds = static_cast<int>(microSecondsSinceEpoch_ % kMicroSecondsPerSecond);
        snprintf(buf, sizeof(buf), "%4d%02d%02d %02d:%02d:%02d.%06d",
                tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday,
                tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec, microSeconds);
    }
    else
    {
        snprintf(buf, sizeof(buf), "%4d%02d%02d %02d:%02d:%02d",
        tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday,
        tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);
    }
    return buf;
}
```

第一个类大体完成。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

`Timestamp`类并不复杂，可以说比较充分的完成了它所需要完成的任务。我们平时在处理问题的时候，也应该有这种分解问题的能力，`Knuth`教授说计算机科学的本质就是

>  控制复杂度

通过封装，我们简化了接口，在使用的时候不需要关注内部的实现，如果有一天我们需要在内部修改或者有了更高效的算法的时候，在保证高层接口不变的情况下，就可完成性能的提升，这也就是Unix设计哲学中的**模块化**的思想，一个工具，做好，且只做一件事。

有个比较明显的感觉，在看了一些操作系统底层的书之后，无论是关于理论，还是接口，再看代码的确感觉更清楚。

#### 参考：

- 深入理解计算机系统
- Linux/Unix编程手册

