---
layout: post
title: muduo源码探索 (二)
categories: [muduo]
description: muduo源码探索-Atomic
keywords: muduo, network, 网络
---

上一次对`Timestamp`进行了封装，这一次试着封装`Atomic`。在多线程编程中，因为多个线程共享同一个内存空间，变量之间很容易共享，但是这极大地便利也会带来某些不便，比如说最常见的一种情况，一个全局`counter`，多个线程每个都递增n次，最后的结果很有可能就出问题，因此需要同步，也就是多个线程对于同一个变量的互斥访问，或者按照《Effective Modern C++》书里提到的，对于变量的*读取-修改-写入（RMW）*操作的原子性。可以借助互斥量轻易地实现线程之间的同步，`muduo`中采取的是`g++`的特殊指令。这里我用C++11标准库中的`atomic`改写，既然标准库提供了这么好用的工具，就没有理由不使用。而且相比而言，`atomic`操作使用了特殊的机器指令，因此一般比互斥量更高效。至于用了什么特殊的指令，Meyers没有说，不过我猜应该是`Compare-and-swap`。

很多无锁的数据结构都是借助`CAS`机制实现的。

锁可以分为悲观锁和乐观锁，悲观锁是认为别的线程会修改值，因此会独占。乐观锁是认为别的线程不会去修改值，而如果修改了，就再次重试。`CAS`就可认为是一种乐观锁。

简单实现如下：

```c
int CompareAndSwap(int *ptr, int expected, int new)
{
    int actual = *ptr;
    if (actual == expected)
    {
        *ptr = new;
    }
    return acutal;
}
```

将内存位置与`expected`比较，如果相等，则说明没有其他线程修改过这个值，就更新为`new`，而如果不相等，则说明内存位置被其他线程修改，不更新，返回旧值，等待下一次尝试。因此多个线程访问同一个变量，只有其中一个会成功，其他的都会失败。

> 我认为原有的值应该是什么，如果是，请更新，否则什么都不做，并告诉我这个值现在是什么

（摘抄自《Java并发编程实践》）

#### Atomic

##### 1. 任务

因为一些类似`Counter`的变量操作，必须保证多个线程并发访问依旧返回正确答案，因此要对这类数据进行封装，减少使用的时候还需要额外的`mutex`提供互斥的访问。

##### 2. 实现

和普通的变量差不多，也就是获取数据，递增，递减等，借助标准库`atomic`提供的功能，并不难

```c++
namespace slack
{

// 不暴露给外部，但又放在头文件里，供内部使用的函数或类所在的命名空间
namespace detail
{
// cannot be copied
template <typename T>
class AtomicIntegerT : noncopyable
{
public:
    AtomicIntegerT() : value_(0)
    {
    }

    T get()
    {
        //return __sync_val_compare_and_swap(&value_, 0, 0);
        return value_.load();

    }

    // 返回原值
    T getAndAdd(T x)
    {
        //return __sync_fetch_and_add(&value_, x);
        return value_.fetch_add(x);
    }

    T addAndGet(T x)
    {
        //return getAndAdd(x) + x;
        return value_ += x;
    }

    T incrementAndGet()
    {
        //return addAndGet(1);
        return ++value_;
    }

    T decrementAndGet()
    {
        //return addAndGet(-1);
        return --value_;
    }

    void add(T x)
    {
        //getAndAdd(x);
        return value_ += x;
    }

    void increment()
    {
        //incrementAndGet();
        ++value_;
    }

    void decrement()
    {
        //decrementAndGet();
        --value_;
    }

    // 返回原值
    T getAndSet(T newValue)
    {
        //return __sync_lock_test_and_set(&value_, newValue);
        return value_.exchange(newValue);
    }

private:
    // FIXME，这里的volatile并不是保证原子性
    //volatile T value_;
    volatile std::atomic<T> value_;

};
```

两点需要注意。

1. `detail`命名空间，只提供文件内部访问，避免暴露给用户，有点像是C语言中`static`，C++语言有匿名空间，陈硕老师在博客里提到匿名空间的某些不利之处，而且给出建议

   > 如果前面的“不利之处”给你带来困扰，解决办法也很简单，就是使用普通具名 namespace。当然，要起一个好的名字，比如 boost 里就常常用 boost::detail 来放那些“不应该暴露给客户，但又不得不放到头文件里”的函数或 class。

2. `volatile`关键字，其实是和多线程没关系的，测试的时候不加也没有报错，这里可能是以防万一吧。参照知乎灵剑老师的回答：

   > 实现写到了类的定义里面，这种写法等于告诉编译器说这个函数是可以内联（inline）的，如果说这个函数被不恰当得内联了，有可能出现连续调用递增的时候，变量的值重用了之前寄存器里的值，造成bug，是否出现这种情况取决于编译器的实现。而归根结底，不是因为你没加volatile，而是因为你应该将这个函数放到单独的cpp里面，这样正常来说就不会有奇怪的效果了。
   >
   > 作者：灵剑
   >
   > 链接：https://www.zhihu.com/question/31490495/answer/88431721
   >
   > 来源：知乎
   >
   > 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

   而且《Effective Modern C++》书里提到：

   >  std::atomic对于并发程序设计有用，但不能用于访问特种内存；volatile对于访问特种内存有用，但不能用于并发程序设计。如果多个线程同时访问的是内存映射IO位置，两者在一起应该是有用的。

   volatile关键字本来的意思是避免编译器的优化，要求每次对于变量的访问都从内存重新读取，而不是使用保存在寄存器中的值。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

概念看上去很简单，代码也不复杂，其实如果深入进去，还是有很多细节要考虑，而且也意识到，有时候问题无法理解，并不是它不符合逻辑，而是知识的广度没有达到。存在的都如此合理，只是当初没有领会到深意罢了。书还是要多看，代码也要多读，慢慢的逻辑就自恰了。

#### 参考：

- https://blog.csdn.net/Solstice/article/details/6186978
- https://www.zhihu.com/question/31490495
- https://segmentfault.com/a/1190000015239603
- 《Operating Systems: Three easy pieces》
- 《Effective Modern C++》

