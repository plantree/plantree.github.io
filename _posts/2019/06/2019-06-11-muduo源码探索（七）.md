---
layout: post
title: muduo源码探索 (七)
categories: [muduo]
description: muduo源码探索-ThreadLocal/ThreadPool
keywords: muduo, network, 网络
---

上一次实现了`Thread`类，作为基础构建（只是对于单个线程的抽象），在具体使用的时候，必然会开启多个线程，这就面临一些问题：比如数据的共享，前面已经看到线程局部数据的妙用；线程的调度，任务的分派和执行，典型的*生产者/消费者模型*。

针对这两个问题，我们在已有工具的基础上，开始组合，构建更复杂的工具。

一个简单的，`ThreadLocal`，通过线程特有数据的方式，管理线程间数据的同步；另一个复杂度的，`ThreadPool`，负责任务的分配，调度线程执行，核心要用到一个队列，条件变量和互斥量用于同步。

#### ThreadLocal

##### 1. 任务

- 封装线程特有数据，使得不同线程访问变量，取得的都是专属的拷贝

##### 2. 实现

线程特有数据的核心，是`键/值存储`，《Unix网络编程》p543页讲述的相当清楚，简单整理一下：内核会为进程维护一个数组，数组中存储的是`Key`结构（标识是否使用，以及值的删除函数）的数组，接着每个线程都有一份特定数据，存储键值对，大体如下：![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190610192147.png)。在使用的时候会申请一个`key`，在对应自己的位置上放置值。删除的时候会调用全局`Key`结构数组中存储的删除函数。

```c++
// key-value
template <typename T>
class ThreadLocal : noncopyable
{
public:
    ThreadLocal()
    {
        // key删除的时候value的dtor
        int ret = pthread_key_create(&pkey_, &ThreadLocal::destructor);
        assert(ret == 0); (void)ret;
    }

    ~ThreadLocal()
    {
        int ret = pthread_key_delete(pkey_);
        assert(ret == 0); (void)ret;
    }

    T &value()
    {
        T *perThreadValue = static_cast<T *>(pthread_getspecific(pkey_));
        // 键对应值不存在，新建
        if (!perThreadValue)
        {
            T *newObj = new T();
            pthread_setspecific(pkey_, newObj);
            perThreadValue = newObj;
        }
        return *perThreadValue;
    }

private:
    static void destructor(void *x)
    {
        T *obj = static_cast<T *>(x);
        delete obj;
    }
    pthread_key_t pkey_;
};
```

只要了解创建线程特有数据的那四个核心函数，理解起来并不复杂。

#### ThreadPool

真正比较复杂的，是线程池，尽管创建的思路很简单：维护一个任务组成的队列，和创建的线程组成的数组，当任务来的时候，主线程作为生产者往队列里放，数组中的线程作为消费者从队列里取得任务。同步是个大问题。

##### 1. 任务

- 实现一个生产者/消费者模型，多线程模型雏形已经形成

##### 2. 实现

成员变量就不少

```c++
class ThreadPool : noncopyable
{
public:
    // 函数对象，线程任务
    typedef std::function<void()> Task;

    explicit ThreadPool(const string &nameArg = string("ThreadPool"));
    ~ThreadPool();

    // Must be called before start()
    void setMaxQueueSize(int maxSize)
    {
        maxQueueSize_ = maxSize;
    }
    void setThreadInitCallback(const Task &cb)
    {
        threadInitCallback_ = cb;
    }

    // 线程数量
    void start(int numThreads);
    void stop();

    const string &name() const 
    {
        return name_;
    }

    size_t queueSize() const;

    void run(Task f);

private:
    bool isFull() const;
    // 线程回调函数
    void runInThread();
    Task take();

    mutable MutexLock mutex_;
    // 生产者、消费者模型
    Condition notEmpty_;
    Condition notFull_;

    string name_;
    Task threadInitCallback_;
    // 线程池
    std::vector<std::unique_ptr<Thread>> threads_;
    // 任务队列
    std::deque<Task> queue_;
    size_t maxQueueSize_;
    bool running_;
};
```

互斥量和条件变量的作用，是为了保护任务队列`deque<Task>`，毕竟生产者必须在任务队列不满的时候才能添加，而消费者必须在任务队列不为空的时候才能取得数据，对于共享变量的操作，自然需要同步的机制。考虑为什么需要两个条件变量？因为一个是用来通知生产者的，一个是用来通知消费者的。只用一个条件变量可不可以？不可以。因为如果是消费者线程发出通知，主线程作为生产者线程被唤醒，是不能执行消费的任务的，两个条件变量，做出了良好区分，互不干扰。

比较复杂的函数只用两个，一个是`void Thread::run(Task task)`，类似于生产任务，一个是`Thread::Task ThreadPool::take()`，类似于消费任务。

```c++
void ThreadPool::run(Task task)
{
    // 线程池为空则直接运行
    if (threads_.empty())
    {
        task();
    }
    else
    {
        //printf("test2 lock: tid=%d, holder=%d\n", CurrentThread::tid(), mutex_.getHolder());
        // 放入任务队列
        MutexLockGuard lock(mutex_);
    
        while (isFull())
        {
            // 任务队列满，等待消费
            notFull_.wait();
        }
        assert(!isFull());

        queue_.push_back(std::move(task));
        // 只通知一个线程消费
        notEmpty_.notify();
    }
}

ThreadPool::Task ThreadPool::take()
{
    MutexLockGuard lock(mutex_);

    // always use a while loop, due to spurious wakeup
    while (queue_.empty() && running_)  // 队列不为空或者不运行都会终止等待
    {
        notEmpty_.wait();
    }
    Task task;
    if (!queue_.empty())
    {
        task = queue_.front();
        queue_.pop_front();
        if (maxQueueSize_ > 0)
        {
            // 通知生产者
            notFull_.notify();
        }
    }
    return task;
}
```

生产的时候，如果遇到发现线程池为空，也就是没有消费者线程，那么主线程就要自己消费。否则，就要放入任务队列，如果任务队列为空，主线程就要睡眠等待，用条件变量`notFull_`控制唤醒的时候，当可以放入任务后，通知生产者线程消费。

消费者线程也是类似的，如果任务队列空着，就要睡眠等待，否则通知生产者线程可以继续往任务队列里放任务了。

`ThreadPool`这个类，综合了前面封装的几个类，组合成一个更复杂的模型。类与类之间的变量传递，借助的是`std::function`，比如线程回调函数的设置，这就是`基于对象`的设计思路，将函数视作一个普通的变量进行传递，模型清楚，但也带来了一些复杂性，不太好分析程序的执行顺序。

接下来还会再次遇到这样的设计思路：在创建类的同时，绑定一个回调函数。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

开始利用封装好的类，组合、拼装成更复杂的工具。线程之间的同步，的确不是一件很容易的事，而且执行的顺序变化莫测，调试也很困难。好在互斥量和条件变量是一对很强大的工具，并且用法也比较固定。依然是对操作系统提供的一些工具的使用，之前看操作系统接口的时候，觉得繁杂无序，其实都是为了解决特定问题，选择趁手的使用就好。

#### 参考：

- 《Unix网络编程》

- 《Linux/Unix系统编程手册》

- 《Linux多线程服务端编程》

  <https://blog.csdn.net/nk_test/article/details/50449470>

