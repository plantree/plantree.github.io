---
layout: post
title: muduo源码探索 (十四)
categories: [muduo]
description: muduo源码探索-Endian/SocketOps
keywords: muduo, network, 网络
---

从今天开始接触网络库`net`的部分。这一部分的内容，望文生义，自然是整个网络库核心的部分，前面的，无论是`base`也好，`log`也好，说白了都只是底层的基础设施，本身是实现不了网络库的功能的，这并不是说就没有意义，只是作为一个铺垫，在接下里的网络库的学习中我们会意识到，前面封装好的工具直接就能拿来使用，不必关心底层的细节，专注于网络库功能的实现，是一件相对来说比较轻松地事情。

还是从简单的类入手，暂时先不去写核心的部分，想`EventLoop`，`Channel`之类的，先把都会用到的一些数据结构封装，这一次先来看`Endian`和`SocketOps`，一个是用来处理大小端的问题，因为主机字节序也许是大端，也许是小端，而网络字节序一定是大端，因此需要一步转换，另一个是对`socket`套接字的简单封装，包含了错误处理的逻辑，不再去直接使用裸露的原始套接字。

#### Endian

##### 1. 任务

- 实现网络字节序和主机字节序的双向转换

##### 2. 实现

`Linux`系统提供了一组并不跨平台的转换函数，而且对于字长也有不同的对应，本身我们的网络库并不跨平台，包括后面使用的`epoll`I/O多路复用模型，因此这些转换函数就够了。简单的封装而已。

```c++
// 本地字节序到网络字节序，非标准
inline uint64_t hostToNetwork64(uint64_t host64)
{
    return htobe64(host64);
}

inline uint32_t hostToNetwork32(uint32_t host32)
{
    return htobe32(host32);
}

inline uint16_t hostToNetwork16(uint16_t host16)
{
    return htobe16(host16);
}

// 网络字节序到本地字节序
inline uint64_t networkToHost64(uint64_t net64)
{
    return be64toh(net64);
}

inline uint32_t networkToHost32(uint32_t net32)
{
    return be32toh(net32);
}

inline uint16_t networkToHost16(uint16_t net16)
{
    return be16toh(net16);
}
```

#### SocketOps

##### 1. 任务

- 对于原始套接字的一些底层操作的封装，如设置非阻塞文件描述符，连接、监听等操作

##### 2. 实现

我们对于套接字的操作有很多，比如所客户端和服务端的连接、监听、接受连接、读、写、关闭等，我们并不能简单的直接使用，因为内部有出错的可能，如果每次都要根据返回值判断，无疑增加了使用的复杂度，而且比较容易忘，因此我们将其封装为包裹函数。

```c++
// create a non-blocking socket file descriptor
int createNonBlockingOrDie(sa_family_t family);

int connect(int sockfd, const struct sockaddr *addr);
void bindOrDie(int sockfd, const struct sockaddr *addr);
void listenOrDie(int sockfd);
// support ipv6
int accept(int sockfd, struct sockaddr_in6 *addr);

ssize_t read(int sockfd, void *buf, size_t count);
ssize_t readv(int sockfd, const struct iovec *iov, int iovcnt);
ssize_t write(int sockfd, const void *buf, size_t count);

void close(int sockfd);
// 关闭写，依旧可读
void shutDownWrite(int sockfd);

// transformation
void toIpPort(char *buf, size_t size, const struct sockaddr *addr);
void toIp(char *buf, size_t size, const struct sockaddr *addr);
void fromIpPort(const char *ip, uint16_t port, struct sockaddr_in6 *addr);
void fromIpPort(const char *ip, uint16_t port, struct sockaddr_in *addr);

// socket opt
int getSocketError(int sockfd);

// some casts
const struct sockaddr *sockaddr_cast(const struct sockaddr_in *addr);
const struct sockaddr *sockaddr_cast(const struct sockaddr_in6 *addr);
struct sockaddr *sockaddr_cast(struct sockaddr_in6 *addr);
const struct sockaddr_in *sockaddr_in_cast(const struct sockaddr *addr);
const struct sockaddr_in6 *sockaddr_in6_cast(const struct sockaddr *addr);

struct sockaddr_in6 getLocalAddr(int sockfd);
struct sockaddr_in6 getPeerAddr(int sockfd);
bool isSelfConnect(int sockfd);

```

有一些对于`sockaddr`和`sockaddr_in`两种地址形式之间的转换比较直接，就跳过。

对于`createNonBlockingOrDie()`函数而言，如果支持在创建套接字的时候直接设置`SOCK_NONBLOCK`或者`SOCK_CLOEXEC`，得到的就是目标套接字，否则还要使用`fcntl`函数在获得套接字上面设置非阻塞和执行时关闭。

`bind`、`listen`、`accept`等其实就是对于原始函数的封装，增加错误处理。

```c++
int sockets::accept(int sockfd, struct sockaddr_in6 *addr)
{
    // 所有连接套接字都是非阻塞
    socklen_t addrlen = sizeof *addr;
#if VALGRIND || defined (NO_ACCEPT4)
    int connfd = ::accept(sockfd, sockaddr_cast(addr), &addrlen);
    setBlockingAndCloseOnExec(connfd);
#else
    // non-blocking, close-on-exec connection
    int connfd = ::accept4(sockfd, sockaddr_cast(addr),
                            &addrlen, SOCK_NONBLOCK | SOCK_CLOEXEC);
#endif
    if (connfd < 0)
    {
        int savedErrno = errno;
        LOG_SYSERR << "sockets::accept";
        switch (savedErrno)
        {
            case EAGAIN:
            case ECONNABORTED:
            case EINTR:
            case EPROTO:    // 协议错误
            case EPERM: // 防火墙阻止
            case EMFILE: // per-process limit on the number of open file descriptors
                // expected error
                errno = savedErrno;
                break;
            case EBADF:
            case EFAULT:
            case EINVAL:
            case ENFILE:
            case ENOBUFS:
            case ENOMEM:
            case ENOTSOCK:
            case EOPNOTSUPP:
                // unexpected errors
                LOG_FATAL << "unexpected error of ::accept " << savedErrno;
                break;
            default:
                LOG_FATAL << "unknown error of ::accept " << savedErrno;
                break;
        }
    }
    return connfd;
}
```

新增加的`accept4`函数可以直接获取非阻塞连接套接字，省却了`fnctl`修改的步骤，并且增加了很丰富的错误检查，区分了`expected`和`unexpected`错误。

```c++
// 地址转换为ip:port字符串
void sockets::toIpPort(char *buf, size_t size,
                        const struct sockaddr *addr)
{
    toIp(buf, size, addr);
    size_t end = ::strlen(buf);
    const struct sockaddr_in *addr4 = sockaddr_in_cast(addr);
    uint16_t port = sockets::networkToHost16(addr4->sin_port);
    assert(size > end);
    snprintf(buf+end, size-end, ":%u", port);   
}

// 地址转换为ip字符串
void sockets::toIp(char *buf, size_t size, 
                    const struct sockaddr *addr)
{
    if (addr->sa_family == AF_INET)
    {
        assert(size >= INET_ADDRSTRLEN);
        const struct sockaddr_in *addr4 = sockaddr_in_cast(addr);
        ::inet_ntop(AF_INET, &addr4->sin_addr, buf, static_cast<socklen_t>(size));
    }
    else if (addr->sa_family == AF_INET6)
    {
        assert(size >= INET6_ADDRSTRLEN);
        const struct sockaddr_in6 *addr6 = sockaddr_in6_cast(addr);
        ::inet_ntop(AF_INET6, &addr6->sin6_addr, buf, static_cast<socklen_t>(size));
    }
}

void sockets::fromIpPort(const char *ip, uint16_t port,
                        struct sockaddr_in *addr)
{
    addr->sin_family = AF_INET;
    addr->sin_port = hostToNetwork16(port);
    if (::inet_pton(AF_INET, ip, &addr->sin_addr) <= 0)
    {
        LOG_SYSERR << "sockets::fromIpPort";
    }
}

void sockets::fromIpPort(const char *ip, uint16_t port, 
                        struct sockaddr_in6 *addr)
{
    addr->sin6_family = AF_INET6;
    addr->sin6_port = hostToNetwork16(port);
    if (::inet_pton(AF_INET6, ip, &addr->sin6_addr) <= 0)
    {
        LOG_SYSERR << "sockets::fromIpPort";
    }
}
```

对于一些`ip`地址到字符串之间的转换，借助的是新型函数，兼容`ipv4`和`ipv6`，`inet_pton()`和`inet_ntop()`。

一个套接字，其实是个四元组，(本机ip，本机port，远程ip，远程port)，因此可以根据一个套接字，获取到这些信息。

```c++
struct sockaddr_in6 sockets::getLocalAddr(int sockfd)
{
    struct sockaddr_in6 localAddr;
    memZero(&localAddr, sizeof localAddr);
    socklen_t addrlen = static_cast<socklen_t>(sizeof localAddr);
    if (::getsockname(sockfd, sockaddr_cast(&localAddr), &addrlen) < 0)
    {
        LOG_SYSERR << "sockets::getLocalAddr";
    }
    return localAddr;
}

struct sockaddr_in6 sockets::getPeerAddr(int sockfd)
{
    struct sockaddr_in6 peerAddr;
    memZero(&peerAddr, sizeof peerAddr);
    socklen_t addrlen = static_cast<socklen_t>(sizeof peerAddr);
    if (::getpeername(sockfd, sockaddr_cast(&peerAddr), &addrlen) < 0)
    {
        LOG_SYSERR << "sockets::getPeerAddr";
    }
    return peerAddr;
}
```

根据获取到到的四元组，就可以接着判断是否为自连接，这是一种很特殊的连接方式，实现方式并不复杂。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

网络编程，其实是很复杂的，直接写一个玩具程序当然简单，直接调用系统的几个调用，就能实现`Echo`服务端、客户端，难的地方在于，网络环境复杂多变，而且错误的出现不可预料，要写一个稳健的，能自动处理各种意外错误的服务器，并且持续不断地运行，不是一件很容易的事。需要对操作系统层面的一些原理和技术有着深刻的洞察和理解，才能预先知道，或者说遇到错误后反思，要避开某些有可能存在问题的地方。编程的思路是一致的，就是降低复杂性，通过封装底层的工具，在构建高层的应用时才会更加方便和得心应手。

#### 参考：

- 《Linux多线程服务端编程》
- 《Linux/Unix系统编程手册》
