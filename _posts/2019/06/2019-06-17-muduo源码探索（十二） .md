---
layout: post
title: muduo源码探索 (十二)
categories: [muduo]
description: muduo源码探索-LogStream/Logging
keywords: muduo, network, 网络
---

关于日志，一共封装了四个类，各司其职，有负责日志流的`LogStream`，也就是将不同的数据类型转换为字符串，有负责核心功能的`Logging`，负责统筹，有负责日志写入到磁盘的`LogFile`，还有个异步日志`AsyncLogging`。今天暂时先只接触两个比较基础的类，`LogStream`和`LogFile`。

整个日志的流向大体是：

`Logger->Impl->LogStream->operator<<FixedBuffer->g_output->g_flush`

#### LogStream

##### 1. 任务

- 重载输出运算符，将各种类型数据输出到内部缓冲区

##### 2. 实现

要实现整个功能，需要一些辅助类的参与，这里实现了`FixedBuffer`和`Fmt`，一个是大小固定的缓冲区，一个是格式化字符串。

```c++
template <int SIZE>
class FixedBuffer : noncopyable
{
public:
    FixedBuffer() 
        : cur_(data_) 
    {
        setCookie(cookieStart);
    }
    ~FixedBuffer()
    {
        setCookie(cookieEnd);
    }

    void append(const char /*restrict*/ *buf, size_t len)
    {
        // FIXME: append partially
        if (implicit_cast<size_t>(avail()) > len)
        {
            memcpy(cur_, buf, len); // copy
            cur_ += len;
        }
    }

    const char *data() const
    {
        return data_;
    }
    int length() const
    {
        return static_cast<int>(cur_ - data_);
    }

    // write to data_ directly
    char *current()
    {
        return cur_;
    }
    int avail() const
    {
        return static_cast<int>(end() - cur_);
    }
    void add(size_t len)
    {
        cur_ += len;
    }

    void reset()
    {
        cur_ = data_;
    }
    // 初始化为0
    void bzero()
    {
        memZero(data_, sizeof data_);
    }

    // for used by GDB
    const char *debugString();
    void setCookie(void (*cookie)())
    {
        cookie_ = cookie;
    }
    // for used by unit test
    string toString() const
    {
        return string(data_, length());
    }
    StringPiece toStringPiece() const 
    {
        return StringPiece(data_, length());
    }

private:
    const char *end() const
    {
        return data_ + sizeof data_;
    }
    // must be outline function for cookies
    // 外部设置标识
    static void cookieStart();
    static void cookieEnd();
    
    // 函数指针
    void (*cookie_)();  
    // 内部缓冲区
    char data_[SIZE];
    // 当前指针
    char *cur_;
};
```

`FixedBuffer`看起来复杂，其实内部就只是对于字符数组的操作，有额外的指针，告诉我们数组已经使用的空间和剩余空间，并且提供了一些额外的辅助函数，比直接操纵原始字符数组要好得多。

```c++
// 辅助format类
// 借助snprintf
class Fmt : noncopyable
{
public:
    template <typename T>
    Fmt(const char *fmt, T val);

    const char *data() const 
    {
        return buf_;
    }
    int length() const
    {
        return length_;
    }
private:
    char buf_[32];
    int length_;
};
```

`Fmt`类就更简单，内部就是封装了`snprintf`，将数据按照格式转化为字符串。

剩下的`LogStream`，内部有个`FixedBuffer`，剩下的大量代码，就是重载不同的类型，以及对于数字按照不同进制进行编码。内部对于字符串的操作，全部转接到`FixedBuffer`上，只专注于输入数据的转换即可。

```c++
const char digits[] = "9876543210123456789";
const char *zero = digits + 9;
static_assert(sizeof digits == 20, "wrong number of digits");

const char digitsHex[] = "0123456789ABCDEF";
static_assert(sizeof digitsHex == 17, "wrong number of digitsHex");

// Efficient Integer to String Conversions, by Matthew Wilson
template <typename T>
size_t convert(char buf[], T value)
{
    T i = value;
    char *p = buf;

    // 倒序计算
    do
    {
        int lsd = static_cast<int>(i % 10);
        i /= 10;
        *p++ = zero[lsd];
    } while (i != 0);
    
    if (value < 0)
    {
        *p++ = '-';
    }
    *p = '\0';
    std::reverse(buf, p);

    return p - buf;
}

// uintptr_t->unsigned long 
size_t convertHex(char buf[], uintptr_t value)
{
    uintptr_t i = value;
    char *p = buf;

    do
    {
        int lsd = i % 16;
        i /= 16;
        *p++ = digitsHex[lsd];
    } while (i != 0);
    
    *p = '\0';
    std::reverse(buf, p);
    return p - buf;
}
```

对于整数的转换，十进制和十六进制（输出指针类型）都是自己额外写的函数，剩下的大部分重载，其实都是使用的类型强制转换+委托。

多说一句，测试程序，使用了C标准库提供的输出函数，C++提供的流操作符，和这里实现的，比较了一下，

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190617203818.png)

发现这三个，整体来说，C++流操作符效率比较高。陈硕老师在《Linux多线程服务端》书里关于`iostream`的说法看来有待商榷，也不能一棍子打死。

#### Logging

##### 1. 任务

- 实现日志的中枢控制系统`Logger`

##### 2. 实现

首先要明确，日志记录，输出的是什么，大致有这么几个要素：日志级别、日志文件、日志所在行，以及根据日志级别决定是否`abort()`。

```c++
// 日志器
class Logger
{
public:
    // 日志级别
    enum LogLevel
    {
        TRACE,
        DEBUG,
        INFO,
        WARN,
        ERROR,
        FATAL,
        NUM_LOG_LEVELS
    };

    // complile time calculation of basename of source file
    class SourceFile    // 从path中提取source file
    {
    public:
        // 模板成员函数(参数是数组)
        template <int N>
        inline SourceFile(const char (&arr)[N]) // 引用数组
            : data_(arr),
            size_(N-1)
        {
            const char *slash = strrchr(data_, '/');
            if (slash)
            {
                data_ = slash + 1;
                size_ -= static_cast<int>(data_ - arr);
            }
        }

        // 参数是指针
        explicit SourceFile(const char *filename)
            : data_(filename)
        {
            const char *slash = strrchr(data_, '/');
            if (slash)
            {
                data_ = slash + 1;
            }
            size_ = static_cast<int>(strlen(data_));
        }

        // member data
        const char *data_;
        int size_;
    };

    // ctor
    Logger(SourceFile file, int line);
    Logger(SourceFile file, int line, LogLevel level);
    Logger(SourceFile file, int line, LogLevel level, const char *func);
    Logger(SourceFile file, int line, bool toAbort);
    ~Logger();

    LogStream &stream()
    {
        return impl_.stream_;
    }

    static LogLevel logLevel();
    static void setLogLevel(LogLevel level);

    // 函数指针
    //typedef void (*OutputFunc)(const char *msg, int len);
    //typedef void (*FlushFunc)();
    using OutputFunc = void(*)(const char *msg, int len);
    using FlushFunc = void(*)();

    static void setOutput(OutputFunc);
    static void setFlush(FlushFunc);

private:
    // pointer to implementation 
    // removes implementation details of a class from its object
    // representation by placing them in a separate class
    class Impl
    {
    public:
        using LogLevel = Logger::LogLevel;
        Impl(LogLevel level, int old_errno, const SourceFile &file, int line);
        void formatTime();
        void finish();

        Timestamp time_;
        LogStream stream_;
        LogLevel level_;
        int line_;
        SourceFile basename_;
    };
    // 内部类
    Impl impl_;
};
```

内部的`SourceFile`类，其实功能简单，就是从一个`path`中提取文件名。`Logger`的构造函数有很多，就是可以根据场景，选择要输出的信息，比如日志级别、行等。而且输出函数和刷新函数的方式，都是函数指针，可以从外部指定，当然也可以选择`default`。有个比较有意思的地方，是`Impl`类，是`implementation`的意思，应该是借的`Piml`写法，也即`pointer to implementation`，这是C++里的一种编程技法，是将类的实现和接口分离，将实现的细节从类里剥离，将它们放在一个独立的类中，降低编译依赖，提高编译速度。于是乎，`Logger`只是作为一个高层的类，统筹全局，从外部拿数据，但是具体的所有操作，比如内部的`LogStream`，再到`FixedBuffer`，都不需要考虑了。

```c++
// Impl ctor
Logger::Impl::Impl(LogLevel level, int saveErrno, const SourceFile &file, int line)
    : time_(Timestamp::now()),
    stream_(),
    level_(level),
    line_(line),
    basename_(file)
{
    formatTime();
    // 缓存tid
    CurrentThread::tid();
    stream_ << T(CurrentThread::tidString(), 6);
    stream_ << T(LogLevelName[level], strlen(LogLevelName[level])) << " ";
    if (saveErrno != 0)
    {
        stream_ << strerror_tl(saveErrno) << " (errno=" << saveErrno << ") ";
    }
}

// 格式化时间并输出到流
void Logger::Impl::formatTime()
{
    int64_t microSecondsSinceEpoch = time_.microSecondsSinceEpoch();
    time_t seconds = static_cast<time_t>(microSecondsSinceEpoch / time_.kMicroSecondsPerSecond);
    int microSeconds = static_cast<int>(microSecondsSinceEpoch % time_.kMicroSecondsPerSecond);
    // 秒数变化, t_lastSecond做缓存
    if (seconds != t_lastSecond)
    {
        t_lastSecond = seconds;
        struct tm tm_time;
        // get formatted time
        ::localtime_r(&seconds, &tm_time);

        int len = snprintf(t_time, sizeof t_time, "%4d%02d%02d %02d:%02d:%02d",
            tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday,
            tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);
        assert(len == 17); (void)len;
    }
    // 左对齐
    Fmt us(".%06dZ ", microSeconds);
    assert(us.length() == 9);
    // output
    stream_ << T(t_time, 17) << T(us.data(), 9);
}

void Logger::Impl::finish()
{
    stream_ << " - " << basename_ << ":" << line_ << "\n";
}
```

其实就是将`Logger`获取到的信息拿过来，接着自己进行处理，错误处理，格式化时间等等。通过一个间接层，`Logger`真正需要实现的任务就很少了。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

在写代码之前，首先应该要明确要完成的任务。没有一个好的问题，就不会得到一个好的答案。当任务明确，然后分解、细化，知道要分割成几个部分，因为一个但问题，往往是由许多个独立的小的模块构成，分别将小的模块构建好，不要忘记**单元测试**，然后再在这些模块的基础上，封装成更高层的应用，就能更好的屏蔽底层实现的细节。

#### 参考：

- 《Linux多线程服务端编程》
- https://en.cppreference.com/w/cpp/language/pimpl
- 
