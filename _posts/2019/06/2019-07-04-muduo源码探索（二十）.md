---
layout: post
title: muduo源码探索 (二十)
categories: [muduo]
description: muduo源码探索-EventLoop
keywords: muduo, network, 网络
---

有了前面的铺垫，就剩下最后的，也是最核心的一个类，`EventLoop`，看名字，事件循环，基本也就是`Reactor`模式的代名词，一个`EventLoop`将相当于一个`Reactor`。这个类比较复杂，内部的元素也很多，功能也很多，分解来看，基本上功能还是比较明确的。

#### Poller

##### 1. 任务

- 实现事件循环类

##### 2. 实现

```c++
// Reactor, at most one per thread
// This is an interface class, so don't expose too much details
class EventLoop : noncopyable
{
public:
    using Functor = std::function<void()>;

    EventLoop();
    ~EventLoop();

    // loops forever. Must be called in the same thread as creation of the object
    void loop();

    // quits loop, not 100% thread safe, better to call through shared_ptr<EventLoop>
    void quit();

    // Time when poll returns, ususlly means data arrival
    Timestamp pollReturnTime() const 
    {
        return pollReturnTime_;
    }

    int64_t iteration() const 
    {
        return iteration_;
    }

    // Runs callback immediately in the loop thread
    // It wakes up the loop, and run the cb
    // If in the same loop thread, cb is run within the function
    // Safe to call from other threads
    // 立马执行
    void runInLoop(Functor cb);
    // Queues callback in the loop thread
    // Runs after finish polling
    // Safe to call from other threads
    // 排队执行
    void queueInLoop(Functor cb);

    size_t queueSize() const;

    // timers

    // runs callback at 'time'
    // safe to call from other threads
    TimerId runAt(Timestamp time, TimerCallback cb);

    // runs callback after delay seconds
    // safe to call from other threads
    TimerId runAfter(double delay, TimerCallback cb);

    // runs callback every intarval seconds
    // safe to call from other threads
    TimerId runEvery(double interval, TimerCallback cb);

    // cancels the timer
    // safe to call from other threads
    void cancel(TimerId timerId);

    // internal usage
    void wakeup();
    void updateChannel(Channel *channel);   // 从Poller中添加或者更新通道
    void removeChannel(Channel *channel);   // 从Poller中删除通道
    bool hasChannel(Channel *channel);

    void assertInLoopThread()
    {
        if (!isInLoopThread())
        {
            abortNotInLoopThread();
        }
    }

    // one loop per thread
    bool isInLoopThread() const 
    {
        return threadId_ == CurrentThread::tid();
    }

    // 事件正在处理
    bool eventHandling() const 
    {
        return eventHandling_;
    }

    static EventLoop *getEventLoopOfCurrentThread();
private:
    void abortNotInLoopThread();
    void handleRead();  // wake up
    void doPendingFunctors();

    void printActiveChannels() const;   // DEBUG

    using ChannelList = std::vector<Channel *>;

    bool looping_;  // atomic
    std::atomic<bool> quit_;     // atomic
    bool eventHandling_;    // atomic
    bool callingPendingFunctos_;    // atomic

    int64_t iteration_;
    const pid_t threadId_;  // local thread ID
    Timestamp pollReturnTime_;

    std::unique_ptr<Poller> poller_;
    std::unique_ptr<TimerQueue> timerQueue_;    // 定时器队列

    int wakeupFd_;  // 用于eventfd
    
    // unlike in TimeQueue, whichi is an internal class
    // we don't expose channel to client
    std::unique_ptr<Channel> wakeupChannel_;    // 绑定wakeupFd_, 纳入poller_管理

    ChannelList activeChannels_;    // Poller中返回的活跃通道
    Channel *currentActiveChannel_; // 正在处理的活跃通道
    
    mutable MutexLock mutex_;
    std::vector<Functor> pendingFunctos_;   // guardedBy mutex_;
};
```

这个类，的确是大，功能丰富。看注释，知道这就是`reactor`，而且一个线程至多有一个，后面会有一些判断的函数。

类的内部，有线程ID，有迭代次数，有一个`Poller`和`TimerQueue`，都是用`unique_ptr`包裹，省却资源管理的复杂，有一个负责唤醒的`eventfd`，以及对应的`Channel`，还有`poll()`出来的需要事件处理的`Channel`列表，因为涉及到一些并发访问问题，因此还需要互斥量。

原则上，`EventLoop`只是负责监听事件，然后将事件`dispatch`给其他的工作线程，但是有些回调事件，必须要`EventLoop`亲自执行，其他线程会将这样的回调函数放入一个`PedingFunctor`的列表中，然后通知`EventLoop`去执行，这也就是`wakeupFd_`的作用，这是一个`evnetfd`，与`timerfd`类似，将事件转换为一个文件描述符，纳入到`Poller`的管理中，而不是使用信号等方式。

```c++
// 匿名空间
namespace 
{
// 当前线程EventLoop对象指针
// 线程局部存储
__thread EventLoop *t_loopInThisThread = nullptr;

// 超时时间
const int kPollTimeMs = 10000;

// 用于事件通知
int createEventfd()
{
    int evtfd = ::eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);
    if (evtfd < 0)
    {
        LOG_SYSERR << "Failed in eventfd";
        abort();
    }
    return evtfd;
}

#pragma GCC diagnostic ignored "-Wold-style-cast"
// 忽略SIGPIPE
class IgnoreSigPipe
{
public:
    IgnoreSigPipe()
    {
        ::signal(SIGPIPE, SIG_IGN);
        LOG_TRACE << "Ignore SIGPIPE";
    }
};
#pragma GCC diagnostic error "-Wold-style-cast"

IgnoreSigPipe initObj;

}   // namespace 
```

有个匿名空间，`EventLoop`类有个线程局部指针，通过这个全局的线程局部数据，保证每个线程至多有一个`EventLoop`。`createEventfd()`比较容易理解，创建一个非阻塞、执行时关闭的事件文件描述符。而忽略`SIGPIPE`事件是“最佳实践”，《Unix网络编程》里有讲，避免客户端已经关闭读，服务端依旧往里写数据，就会触发`SIGPIPE`，默认是终止程序，这里选择忽略。

```c++
EventLoop::EventLoop()
    : looping_(false),
    quit_(false),
    eventHandling_(false),
    callingPendingFunctos_(false),
    iteration_(0),
    threadId_(CurrentThread::tid()),
    poller_(Poller::newDefaultPoller(this)),    // default epoll
    timerQueue_(new TimerQueue(this)),
    wakeupFd_(createEventfd()), // 唤醒事件
    wakeupChannel_(new Channel(this, wakeupFd_)),
    currentActiveChannel_(nullptr)
{
    LOG_TRACE << "EventLoop created " << this << " in thread " << threadId_;
    // 如果当前线程已经创建了EventLoop对象，终止（LOG_FATAL）
    if (t_loopInThisThread)
    {
        LOG_FATAL << "Another EventLoop " << t_loopInThisThread
            << " exists in this thread " << threadId_;
    }
    else 
    {
        t_loopInThisThread = this;
    }
    wakeupChannel_->setReadCallback(std::bind(&EventLoop::handleRead, this));
    // we always reading the wakeupfd
    wakeupChannel_->enableReading();
}

EventLoop::~EventLoop()
{
    LOG_DEBUG << "EventLoop " << this << " of thread " << threadId_
        << " destructors in thread " << CurrentThread::tid();
    // remove channel，其他的会自动析构
    wakeupChannel_->disableAll();
    wakeupChannel_->remove();
    ::close(wakeupFd_);
    t_loopInThisThread = nullptr;
}
```

构造函数可是够复杂的，不仅要标记一些状态，而且要创建`Poller`、`TimerQueue`，一个`eventfd`和其对应的`Channel`，都是`has a`的关系。记得设置`wakeupFd_`回调函数，`enableReading()`的背后借助的是`EventLoop::update(Channel)`，后面会看到，`EventLoop`其实将这个行为转发给`Poller`完成。

析构函数，就是移除`wakeUp_`的`Channel`，然后关闭文件描述符。

```c++
// 事件循环，不能跨越线程调用
// 只能在创建对象的线程中
void EventLoop::loop()
{
    assert(!looping_);
    assertInLoopThread();

    looping_ = true;
    quit_ = false;
    LOG_TRACE << "EventLoop " << this << " start looping";

    // 无限循环，除非被中止
    while (!quit_)
    {
        activeChannels_.clear();
        pollReturnTime_ = poller_->poll(kPollTimeMs, &activeChannels_);
        ++iteration_;
        if (Logger::logLevel() <= Logger::TRACE)
        {
            printActiveChannels();
        }
        // TODO sort channel by priority
        eventHandling_ = true;
        for (Channel *channel : activeChannels_)
        {
            currentActiveChannel_ = channel;
            currentActiveChannel_->handleEvent(pollReturnTime_);
        }
        currentActiveChannel_ = nullptr;
        eventHandling_ = false;

        // 处理挂起的的回调函数
        doPendingFunctors();
    }

    LOG_TRACE << "EventLoop " << this << " stop looping";
    looping_ = false;
}

// 该函数可以跨线程调用
void EventLoop::quit()
{
    quit_ = true;
    // 非本线程调用，要唤醒
    if (!isInLoopThread())
    {
        wakeup();
    }
}
```

`loop()`是个无尽的循环，不断的使用`Poller`轮询出事件到达的列表，接着执行`Channel`事先绑定的回调事件，不仅如此，还要去执行其他线程放进来的挂起的回调函数。

如果要取消无尽循环发现不是在本线程内，就要立马唤醒。

```c++
// 在IO线程中执行回调函数，可以跨线程调用
void EventLoop::runInLoop(Functor cb)
{
    if (isInLoopThread())
    {
        // 当前IO线程，同步调用
        cb();
    }
    else 
    {
        // 其他线程调用则放入队列
        queueInLoop(std::move(cb));
    }
}

void EventLoop::queueInLoop(Functor cb)
{
    // 多线程并发访问，要用锁
    {
        MutexLockGuard lock(mutex_);
        pendingFunctos_.push_back(std::move(cb));
    }

    // 调用queueInLoop的线程不是IO线程需要唤醒
    // 或者调用queueInLoop的线程是IO线程，并且此时正在处理pending functor需要唤醒
    // 只有IO线程的事件回调中queueInLoop才不需要唤醒
    if (!isInLoopThread() || callingPendingFunctos_)
    {
        wakeup();
    }
}
```

如果某些回调函数要在IO线程内执行，就要判断是否在IO线程，如果在，则直接执行，否则就要放入队列中等待被IO线程执行。

```c++
TimerId EventLoop::runAt(Timestamp time, TimerCallback cb)
{ 
    return timerQueue_->addTimer(std::move(cb), time, 0.0);
}

TimerId EventLoop::runAfter(double delay, TimerCallback cb)
{
    Timestamp time(addTime(Timestamp::now(), delay));
    return runAt(time, cb);
}

TimerId EventLoop::runEvery(double interval, TimerCallback cb)
{
    Timestamp time(addTime(Timestamp::now(), interval));
    return timerQueue_->addTimer(cb, time, interval);
}

void EventLoop::cancel(TimerId timerId)
{
    return timerQueue_->cancel(timerId);
}
```

对于定时器事件，添加和取消，基本都是转换到底层的`TimerQueue`中执行。

```c++
void EventLoop::updateChannel(Channel *channel)
{
    assert(channel->ownerLoop() == this);
    assertInLoopThread();

    // 实际操作转为Poller执行
    poller_->updateChannel(channel);
}

void EventLoop::removeChannel(Channel *channel)
{
    assert(channel->ownerLoop() == this);
    assertInLoopThread();
    // 正在处理事件
    if (eventHandling_)
    {
        // 要么正在处理，要么不在activeChannels_列表
        assert(currentActiveChannel_ == channel || 
            std::find(activeChannels_.begin(), activeChannels_.end(), channel) == activeChannels_.end());
    }
    poller_->removeChannel(channel);
}

bool EventLoop::hasChannel(Channel *channel)
{
    assert(channel->ownerLoop() == this);
    assertInLoopThread();
    return poller_->hasChannel(channel);
}
```

对于`Channel`的添加和移除，都是调用的底层`Poller`。

```c++
void EventLoop::wakeup()
{
    uint64_t one = 1;
    // 写入，唤醒
    ssize_t n = ::write(wakeupFd_, &one, sizeof one);
    if (n != sizeof one)
    {
        LOG_ERROR << "EventLoop::wakeup() writes " << n << " bytes instead of 8";
    }
}

// 响应读事件
void EventLoop::handleRead()
{
    uint64_t one = 1;
    ssize_t n = ::read(wakeupFd_, &one, sizeof one);
    if (n != sizeof one)
    {
        LOG_ERROR << "EventLoop::handleRead() reads " << n << " bytes instead of 8";
    }
}

// 执行挂起回调
void EventLoop::doPendingFunctors()
{
    std::vector<Functor> functors;
    callingPendingFunctos_ = true;

    {
        MutexLockGuard lock(mutex_);
        // 清空回调队列，交换到局部变量，缩小临界区
        functors.swap(pendingFunctos_);
    }

    for (const Functor &functor : functors)
    {
        functor();
    }

    callingPendingFunctos_ = false;
}
```

换新`EventLoop`是一件很简单的事情，直接往`wakeupFd_`写入8字节的数据，就会触发该文件描述符的可读事件，读回调函数就是将写入的字节读出，避免一直触发。IO线程需要唤醒，是当其他线程做了一些工作，然后需要IO线程参与，比如修改`Channel`，增删定时器之类的。

对于挂起的回调函数列表，这里使用了一个小技巧，在临界区将全局变量`swap`到局部变量，缩小了临界区，至此也不会再有并发访问的问题了。依次执行列表中的回调函数即可。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

`EventLoop`就是`Reactor`，内部有个无限的循环，通过`Poller`反复的`poll()`出到来的事件，然后处理，记住每个线程至多有一个`EventLoop`，否则程序就会报错。因为涉及到多线程并发访问的问题，因此需要一些额外的同步机制，不仅如此，有些操作必须在IO线程内做，这也是为什么前面的几个类的内部都有一个`EventLoop`的指针，方便回调。内部还有一个`TimerQueue`，定时器绑定了回调函数，时间一到，事件就会触发，执行回调函数。整个模型已经很清楚，但是只是一个线程，多线程的话，就有多个`Reactor`要处理了。

#### 参考：

- 《Linux多线程服务端编程》
- 《Linux/Unix系统编程手册》
