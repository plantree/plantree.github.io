---
layout: post
title: muduo源码探索 (六)
categories: [muduo]
description: muduo源码探索-Thread
keywords: muduo, network, 网络
---

这一次的任务比较复杂，要实现`Thread`类。因为`muduo`库使用的是Linux系统下的多线程模型，因此`Thread`类是一个很核心、很关键，也是需要额外多注意的类。之前`CurrentThread`中剩余几个函数没有实现，这里一并带出。封装的基础，还是Linux的`Pthread`线程库，在这个基础上，还会实现线程池等应用工具。

#### Thread

##### 1. 任务

- 封装`Pthread`线程库，作为基础类，便于构建更高层的基础设施

##### 2. 实现

成员变量并不复杂。

```c++
class Thread : noncopyable
{
public:
    // 回调函数
    typedef std::function<void ()> ThreadFunc;
    // move threadFunc
    // 回调函数和线程名字
    explicit Thread(ThreadFunc, const string &name = string());
    ~Thread();

    void start();
    int join();     // return pthread_join

    bool started() const { return started_; }
    pthread_t pthreadId() const { return pthreadId_; }
    pid_t tid() const { return tid_; }
    const string &name() const { return name_; }

    static int numCreated() { return numCreated_.get(); }

private:
    void setDefaultName();

    bool started_;
    bool joined_;
    pthread_t pthreadId_;   // 线程库id
    pid_t tid_;             // 内核线程id，其实也是进程id
    ThreadFunc func_;       // 回调函数
    string name_;           // 线程名字
    CountDownLatch latch_;  // 同步工具
    
    // 线程计数，类共享
    static AtomicInt32 numCreated_;
};
```

每个线程都有回调函数，在创建的时候传入，毕竟线程的出现，就是为了完成任务。每个线程都有自己的id，这里区分了两个，`pthreadId_`是线程库的id，是进程空间的，保证每个进程的线程id都是不同的，但是并不能保证全局的唯一性，而线程的真实id，也就是内核层面的线程标识，可以通过Linux的系统调用获取，而且说的更直接一些，就是一个进程id，因为Linux创建线程和进程的方式是大致相同的。

可以看到这里有个统计线程数量的原子计数器，我们不必再去关心它操作的原子性，因为之前已经封装，而且经过了测试，用起来就很踏实。

`Thread`的实现代码里，有个`detail`命名空间，含有一些辅助函数和类，并且避免暴露给外部。

```c++
pid_t gettid()
{
    // 获取全局唯一PID标识，glibc没提供,借助Linux系统调用
    return static_cast<pid_t>(::syscall(SYS_gettid));
}

void afterFork()
{
    slack::CurrentThread::t_cachedTid = 0;
    slack::CurrentThread::t_threadName = "main";
    // cacheTid
    slack::CurrentThread::tid();
}

class ThreadNameInitializer
{
    public:
    ThreadNameInitializer()
    {
        slack::CurrentThread::t_threadName = "main";
        slack::CurrentThread::tid();
        // FIXME
        // fork()的子进程只会继承main thread，同时继承mutex，如果不是main thread锁住，那么就不会被解锁 
        // 注册fork回调，万一fork就清空缓存，避免使用相同的缓存tid
        pthread_atfork(nullptr, nullptr, &afterFork);
    }
};

// 注册回调
ThreadNameInitializer init;
```

这里需要注意的是`pthread_atfork`函数的使用，一般要尽量避免多线程、多进程混合使用，容易出问题，因为子线程`fork`出来的进程，里面只包含一个线程，其他线程都丢失了。想象一个场景，同一进程里，另一个线程锁住一个互斥量，一个线程`fork`出来一个进程，复制来的互斥量是锁住的，而且没有对应的解锁线程。因此`pthread_atfork`就是注册一个函数，在`fork`的时候，在父进程处理一些事情，子进程也处理一些事情，然后才完成进程的创建。这里也是的，因为每个线程都有唯一的`t_cachedTid`，如果`fork`一个子进程，就应该丢弃之前复制来的线程名字，重新计算。

剩余的`CurrentThread`的代码在这里：

```c++
/* CurrentThread function */
void CurrentThread::cachedTid()
{
    // lazy cache
    if (t_cachedTid == 0)
    {
        t_cachedTid = detail::gettid();
        t_tidStringLength = snprintf(t_tidString, sizeof t_tidString, "%5d ", t_cachedTid);
        assert(t_tidStringLength == 6);
    }
}

bool CurrentThread::isMainThread()
{
    // 线程名字与进程名字相同则为主线程
    return tid() == ::getpid();
}

void CurrentThread::sleepUsec(int64_t usec)
{
    struct timespec ts = {0, 0};
    ts.tv_sec = static_cast<time_t>(usec / Timestamp::kMicroSecondsPerSecond);
    ts.tv_nsec = static_cast<long>(usec % Timestamp::kMicroSecondsPerSecond);
    ::nanosleep(&ts, nullptr);
}
```

线程的`tid`只有在真正用到的时候才会获取，而且会缓存起来，不会反复的调用`detail::gettid()`。

有了这些辅助函数，线程就很容易实现:

```c++
/* Thread function */
AtomicInt32 Thread::numCreated_;    // 初始化为0

Thread::Thread(ThreadFunc func, const string &name)
    : started_(false),
    joined_(false),
    pthreadId_(0),
    tid_(0),
    func_(std::move(func)),
    name_(name),
    latch_(1)
{
    setDefaultName();
}

Thread::~Thread()
{
    if (started_ && !joined_)
    {
        // no joined and detach
        pthread_detach(pthreadId_);
    }
}

void Thread::setDefaultName()
{
    int num = numCreated_.incrementAndGet();
    if (name_.empty())
    {
        char buf[32];
        snprintf(buf, sizeof buf, "Thread%d", num);
        name_ = buf;
    }
}

void Thread::start()
{
    assert(!started_);
    started_ = true;
    // FIXME: move func
    // prepare data
    detail::ThreadData *data = new detail::ThreadData(func_, name_, &tid_, &latch_);
    if (pthread_create(&pthreadId_, nullptr, &detail::startThread, data) != 0)
    {
        // error
        started_ = false;
        delete data;
        // LOG_SYSFATAL << "Failed in pthread_create";
        abort();
    }
    else 
    {
        // 等待同步
        latch_.wait();
        assert(tid_ > 0);
    }
}

int Thread::join()
{
    assert(started_);
    assert(!joined_);
    joined_ = true;
    return pthread_join(pthreadId_, nullptr);
}
```

静态成员不要忘记在全局定义。

每次新建一个线程，都会把计数器增加1。

`Thread::start()`函数略微复杂一些，核心其实就是`pthread_create()`，就是创建出一个线程，如果已经实现了`ThreadData`类和线程函数，就不复杂了。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

到目前位置，都还是封装底层基础设施。其实封装的思路，在学习C++的时候一直都知道，但是具体如何使用，为什么这样用，并不是特别了解。在写`Thread`类的时候，已经初步有了这么一种感觉：封装的意义，就在于屏蔽复杂性，就比如你需要一个原子类，如果之前已经实现好，在使用的时候我就完全不会考虑底层是怎么实现数据的互斥访问和修改的，只专注于当前类的实现。各自之间，耦合度很小，而且各自都经过单元测试，用起来就很放心。工具不是摆设，要为我所用，选择最简单的，恰好解决你需要解决的问题，足矣。另外，要注意细节！

#### 参考：

- https://linux.die.net/man/3/pthread_atfork

- 《Linux多线程服务端编程》

  

