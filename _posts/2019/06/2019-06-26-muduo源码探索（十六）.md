---
layout: post
title: muduo源码探索 (十六)
categories: [muduo]
description: muduo源码探索-Buffer
keywords: muduo, network, 网络
---

在具体的写网络库核心代码的时候，还是先把周边的工具写好。这次写的是`Buffer`类，是作为应用空间的缓冲区。我们都知道，套接字的传输，是从用户空间传递到内核空间，也有可能从内核空间传递到用户空间。之所以在用户空间实现自己的缓冲区，陈硕老师在《Linux多线程服务端编程》中已经写的相当清楚，说白了是为了便于使用。因为如果内核空间满或者空的时候，读或者写就会阻塞，这就会降低数据传输的效率。网络库作为使用时候的中间层，应该代为管理数据的传输，用户在使用的时候，不必关注数据何时传输和收到，直接委托给用户空间的缓冲区，读写操作都是在缓冲区上进行，从内核空间拿到的，或者将要传递的数据都是在缓冲区中。

理论上，一个套接字内部，应该有读、写两个独立的缓冲区。

#### Buffer

##### 1. 任务

- 实现用户空间缓冲区

##### 2. 实现

缓冲区，看起来是一件复杂的数据结构，其实就是一个数组`vector`，但是需要一些额外的索引，标记读写的状态。

```
// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer
// +-------------------+------------------+------------------+
// | prependable bytes |  readable bytes  |  writable bytes  |
// |                   |     (CONTENT)    |                  |
// +-------------------+------------------+------------------+
// |                   |                  |                  |
// 0      <=      readerIndex   <=   writerIndex    <=     size
```

数组看起来大致是这个样子，有个读指针，有个写指针，标记读写的位置，之所以不用迭代器，是因为`vector`在动态扩增的时候，迭代器就失效，因此只要有实际索引，就可以动态的定义迭代器，很方便。

当有数据进来，写指针后移，读出数据的时候，读指针右移，这么看倒是有些像生产者、消费者模型，不过这里的并发访问不是问题，因为读写操纵的数组位置是不同的，只要协调好可读、可写的位置终点，就不会出问题。

当读指针走到与写指针同样的位置，说明写入的数据已经读完，两者就可以同时`reset`到起点。数组的前面还有一小部分空间，可以增加一些额外信息，但是很有限。

当写入的数据很快，来不及读的时候，就有可能发生数组的动态扩增，`vector`会自动的实现。有一种特殊情况，就是读到中间部分，前面是空的，可以写，但是写指针后面又没有足够的空间，这就发生了缓冲区的碎片化，需要内部腾挪，将数据整体前移，后端就有足够的空间写，也就不需要数组的扩增。

整体来看思路不算复杂，但是细节比较多要注意的地方。而且很多代码都是大体上重复，注意缓冲区中的数据是网络字节序，因此需要一些数据变换。

```c++
// 收缩，保留reserve个字节
void shrink(size_t reserve)
{
    // FIXME: use vector::shrink_to_fit() if possible
    Buffer other;   // empty
    // 只保留可读和预留空间
    other.ensureWritableBytes(readableBytes()+reserve);
    other.append(toStringPiece());
    swap(other);
}

void makeSpace(size_t len)
{
    // 空间不够大，resize
    if (writableBytes() + prependableBytes() < len + kCheapPrepend)
    {
        // FIXME: move readable data
        buffer_.resize(writerIndex_ + len);
    }
    // 空间够，但是不连续，手动碎片化整理
    else
    {
        // move readable data to the front, make space inside buffer
        // 内部腾挪
        assert(kCheapPrepend < readerIndex_);
        size_t readable = readableBytes();
        std::copy(begin()+readerIndex_,
                  begin()+writerIndex_,
                  begin()+kCheapPrepend);
        readerIndex_ = kCheapPrepend;
        writerIndex_ = readerIndex_ + readable;
        assert(readable == readableBytes());
    }
}
```

有的时候缓冲区过大，这里指的是`capacity`，需要收缩空间，就可以额外找一个空的缓冲区，将两个缓冲区的数据交换。

比较复杂的是当写的时候发现空间不够，其实也不一定是真的不够，也许缓冲区前面还有很大的一片空间，这就需要内部的数据移动，整体前移，给缓冲区尾部腾出更多的空间，这样就不需要重新扩增，否则就需要`resize`。

有一点没有说，补充一下，`Buffer`中的读取字符串和移动`readerIndex_`是分离的两个动作。

```c++
ssize_t Buffer::readFd(int fd, int *saveErrno)
{
    char extraBuf[65535];
    struct iovec vec[2];
    const size_t writable = writableBytes();
    // 第一块缓冲区
    vec[0].iov_base = begin() + writerIndex_;
    vec[0].iov_len = writable;
    // 第二块缓冲区
    vec[1].iov_base = extraBuf;
    vec[1].iov_len = sizeof extraBuf;
    
    const int iovcnt = (writable < sizeof extraBuf) ? 2 : 1;
    const ssize_t n = sockets::readv(fd, vec, iovcnt);
    // error
    if (n < 0)
    {
        *saveErrno = errno;
    }
    else if (implicit_cast<size_t>(n) <= writable)  // 第一块缓冲区足够
    {
        // 没有使用栈上空间
        writerIndex_ += n;
    }
    else    // 第一块不够， append
    {
        // update writerIndex_
        writerIndex_ = buffer_.size();
        append(extraBuf, n-writable);
    }
    return n;
}
```

对于`readFd`，从文件描述符读取数据，这里采取的是分散读`readv`，将数据读取到两个缓冲区，其中一个在栈上，为什么？直接读进`Buffer`不可以吗？

如果要读取的数据量太大，就会把`Buffer`撑爆，预先并不知道要读多少，因此`Buffer`面临反复的扩容，而且对于`vector`而言，扩容的操作，涉及到内部对象的移动，是一件十分耗时的行为。因此先暂时读到一个大块栈上空间，然后整体添加到缓冲区，这样就把多次的操作化简为只有一次。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

写程序的时候，首先就要知道，为什么要写？如果写出来的代码用不到，那么即便是效率再高也是没有用的。当然对于新手而言，很难知道什么是有用，什么是没有用的，毕竟还缺乏一个宏观而深刻的理解，因此在这个阶段，就是多阅读优秀的代码，理解作者的思路和逻辑。这里的`Buffer`类，实现的功能，其实并不是很复杂，但是理解作者为什么这样设计，背后的原因，是很值得一番探讨的。

#### 参考：

- 《Linux多线程服务端编程》
- 《Linux/Unix系统编程手册》
