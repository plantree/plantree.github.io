---
layout: post
title: muduo源码探索 (十五)
categories: [muduo]
description: muduo源码探索-InetAddress/Socket
keywords: muduo, network, 网络
---

有了前面两个封装的底层函数，我们就可以在其基础上，构建两个基础类，`InetAddress`和`Socket`，可以说前面的两个，封装的是操作，这两个，封装的是对象。一个负责维护地址信息，一个负责维护套接字信息。

#### InetAddress

##### 1. 任务

- 封装IP地址

##### 2. 实现

ip地址有ipv4和ipv6，但是在这个类里被统一，这个是一个`POD`数据类型，内部只有一个成员，使用的是`union`，内部元素或者是ipv4地址，或者是ipv6地址。这是一个可以拷贝的类，毕竟成员变量只有一个。创建的时候给出字符串形式的ip地址，以及端口号，和是不是ipv6等信息，内部成员函数都是对于ip地址的一些常见操作，基本已经在前面实现过了。

```c++
// wrapper of sockaddr_in
// POD interface class (可以与C兼容)
class InetAddress : public copyable
{
public:
    // constructs an endpoint with given port number,
    // mostly used in TcpServer listening
    // 不指定ip则为INADDR_ANY
    explicit InetAddress(uint16_t port = 0, bool loopbackOnly = false,
                        bool ipv6 = false);

    // constructs an endpoint with given ip and port
    InetAddress(const StringArg ip, uint16_t port, bool ipv6 = false);

    // constructs an endopoint with given struct @c sockaddr_in
    // mostly used when accepting new connections
    explicit InetAddress(const struct sockaddr_in &addr)
        : addr_(addr)
    {
    }

    explicit InetAddress(const struct sockaddr_in6 &addr)
        : addr6_(addr)
    {
    }

    sa_family_t family() const 
    {
        return addr_.sin_family;
    }
    string toIp() const;
    string toIpPort() const;
    uint16_t toPort() const;

    // __attribute__((deprecated))表示函数是过时的
    // 编译器会发出警告
    string toHostPort() const __attribute__ ((deprecated))
    {
        return toIpPort();
    }

    // default copy/assignment are okay

    const struct sockaddr *getSockAddr() const 
    {
        return sockets::sockaddr_cast(&addr6_);
    }
    void setSockAddrInet6(const struct sockaddr_in6 &addr6)
    {
        addr6_ = addr6;
    }

    uint32_t ipNetEndian() const;
    uint16_t portNetEndian() const
    {
        return addr_.sin_port;
    }

    // resolve hostname to IP address, not changing port of sin_family
    // return true on success
    // thread safe
    static bool resolve(StringArg hostName, InetAddress *result);

    // set IPv6 ScopeID
    void setScopeId(uint32_t scope_id);

private:
    union 
    {
        struct sockaddr_in addr_;
        struct sockaddr_in6 addr6_;
    };
};
```

对象里实现了一个静态成员函数，用于解析域名到一个ip地址，这个DNS服务，使用的是`gethostbyname_r`，看名字就知道这是一个线程安全的版本，肯定需要我们往里传入一些自己的定义的局部变量。解析的方式，就按照函数的模板写即可。

```c++
bool InetAddress::resolve(StringArg hostName, InetAddress *out)
{
    assert(out != nullptr);
    struct hostent hent;
    struct hostent *he = nullptr;
    int herrno = 0;
    memZero(&hent, sizeof hent);

    // DNS resolve
    int ret = gethostbyname_r(hostName.c_str(), &hent, t_resolveBuffer, sizeof t_resolveBuffer, &he, &herrno);
    // success
    if (ret == 0 && he != nullptr)
    {
        assert(he->h_addrtype == AF_INET && he->h_length == sizeof(uint32_t));
        out->addr_.sin_addr = *reinterpret_cast<struct in_addr *>(he->h_addr);
        return true;
    }
    else 
    {
        if (ret)
        {
            LOG_SYSERR << "InetAddress::resolve";
        }
        return false;
    }
}
```

#### Socket

##### 1. 任务

- 将套接字文件描述符封装为一个类，便于管理和操作底层套接字

##### 2. 实现

我们知道，套接字其实就是一个文件描述符，但是这个文件描述符还有点特殊，因为上面的一些操作很独特，连接、关闭以及读写等等。我们这里，将每一个套接字，都封装为一个类，成员变量只有一个，但是围绕成员变量的辅助成员函数倒有不少。

```c++
// wrapper of socket file descriptor
// it closed the sockfd when destructs
// thread safe, all operations are delegated to OS

class Socket : noncopyable
{
public:
    explicit Socket(int sockfd)
        : sockfd_(sockfd)
    {
    }

    ~Socket();

    int fd() const 
    {
        return sockfd_;
    }

    // return true if success
    bool getTcpInfo(struct tcp_info *) const;
    bool getTcpInfoString(char *buf, int len) const;
    
    // abort if address in use
    void bindAddress(const InetAddress &localAddr);
    // abort if address in use
    void listen();

    // on success, returns a non-negative integer that is
    // a descriptor for the accepted socket, which has been
    // set to non-blocking and close-on-exec. *peeraddr is assigned
    // On error, -1 is returned and *peeraddr is untouched
    int accept(InetAddress *peerAddr);

    void shutdownWrite();

    // Enable/disable TCP_NODELY(Nagel算法)
    void setTcpNoDelay(bool on);

    // Enable/disbale SO_REUSEADDR
    void setReuseAddr(bool on);

    // Enable/disable SO_REUSEPORT
    void setReusePort(bool on);

    // Enable/disbale SO_KEEPALIVE
    // 指定期探测连接是否存在，如果应用层有心跳，就不必设置
    void setKeepAlive(bool on);
    
private:
    const int sockfd_;
};
```

依旧是借助`RAII`的思路，析构的时候关闭底层文件描述符。

```c++
Socket::~Socket()
{
    sockets::close(sockfd_);
}

bool Socket::getTcpInfo(struct tcp_info *tcpi) const 
{
    socklen_t len = sizeof(*tcpi);
    memZero(tcpi, len);
    return ::getsockopt(sockfd_, SOL_TCP, TCP_INFO, tcpi, &len) == 0;
}

bool Socket::getTcpInfoString(char *buf, int len) const 
{   
    struct tcp_info tcpi;
    bool ok = getTcpInfo(&tcpi);
    if (ok)
    {
        snprintf(buf, len, "unrecovered=%u "
                "rto=%u ato=%u snd_mss=%u rcv_mss=%u "
                "lost=%u retrans=%u cwnd=%u total_retrans=%u",
                "sshthresh=%u cwnd=%u total_retrans=%u",
                tcpi.tcpi_retransmits,  // number of unrecovered [RTO] timeouts
                tcpi.tcpi_rto,          // retransmit timeout in usec
                tcpi.tcpi_ato,          // predicted tick of soft clock in usec
                tcpi.tcpi_snd_mss,      
                tcpi.tcpi_rcv_mss,
                tcpi.tcpi_lost,         // lost packets
                tcpi.tcpi_retrans,      // retransmitted packets out
                tcpi.tcpi_rtt,          // smoothed round trip time in usec
                tcpi.tcpi_rttvar,       // medium deviaion
                tcpi.tcpi_snd_ssthresh,
                tcpi.tcpi_snd_cwnd,
                tcpi.tcpi_total_retrans // total retransmits for entire connection 
                );
    }
    return ok;
}
```

每个套接字上的tcp的信息我们可以获取到，帮助debug。

```c++
void Socket::bindAddress(const InetAddress &addr)
{
    sockets::bindOrDie(sockfd_, addr.getSockAddr());
}

void Socket::listen()
{
    sockets::listenOrDie(sockfd_);
}

int Socket::accept(InetAddress *peerAddr)
{
    struct sockaddr_in6 addr;
    memZero(&addr, sizeof addr);
    int connfd = sockets::accept(sockfd_, &addr);
    if (connfd >= 0)
    {
        peerAddr->setSockAddrInet6(addr);
    }
    return connfd;
}

void Socket::shutdownWrite()
{
    sockets::shutDownWrite(sockfd_);
}

void Socket::setTcpNoDelay(bool on)
{
    int optval = on ? 1 : 0;
    int ret = ::setsockopt(sockfd_, IPPROTO_TCP, TCP_NODELAY,
                &optval, static_cast<socklen_t>(sizeof optval));
    if (ret < 0)
    {
        LOG_SYSERR << "setTcpNoDelay";
    }   
}

void Socket::setReuseAddr(bool on)
{
    int optval = on ? 1 : 0;
    int ret = ::setsockopt(sockfd_, SOL_SOCKET, SO_REUSEADDR,
                &optval, static_cast<socklen_t>(sizeof optval));
    if (ret < 0)
    {
        LOG_SYSERR << "setReuseAddr";
    }   
}

void Socket::setReusePort(bool on)
{
#ifdef SO_REUSEPORT
    int optval = on ? 1 : 0;
    int ret = ::setsockopt(sockfd_, SOL_SOCKET, SO_REUSEPORT,
                &optval, static_cast<socklen_t>(sizeof optval));
    if (ret && on)
    {
        LOG_SYSERR << "setReusePort";
    }
#else 
    if (on)
    {
        LOG_ERROR << "setReusePort is not supported";
    }
#endif
}

// 检测对端主机是否崩溃或不可达
void Socket::setKeepAlive(bool on)
{
    int optval = on ? 1 : 0;
    int ret = ::setsockopt(sockfd_, SOL_SOCKET, SO_KEEPALIVE,
                &optval, sizeof optval);
    if (ret < 0)
    {
        LOG_SYSERR << "setKeepAlive";
    }   
}
```

附加在套接字上的操作真不少，好在我们之前已经将一些操作封装为函数，因此使用的时候并不繁琐。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

我们在写程序的时候，首要考虑的，就是能否封装，将复杂的操作保留在内部，调用的时候也不比关注错误的处理。当然，具体要实现的功能，是事先设计好的，这个过程我们看不到，看到的都已经是完成了的代码。

#### 参考：

- 《Linux多线程服务端编程》
- 《Linux/Unix系统编程手册》
