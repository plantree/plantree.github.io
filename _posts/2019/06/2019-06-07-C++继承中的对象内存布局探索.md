---
layout: post
title: C++继承中的对象内存布局探索
categories: [C++]
description: C++继承中的对象内存布局探索
keywords: C++, practice
---

前段时间看了侯捷老师翻译的《深度探索C++对象模型》，关于C++的底层实现，讲的比较抽象，务虚，不过有些内存中对象布局的示意图画的倒是极好，很清楚。当然这还只是理论层面上的，具体的实现，不同编译器的考量是不一样的，本着求真务实的态度（脱离实际的理论是缺乏生命力的），自己探索了一番，借助一些现成的工具。

#### Goal

- 研究不含虚函数单继承、含有虚函数单继承、普通多继承以及虚继承四种情况下，C++对象的内存布局

#### Environment

- OS： ubuntu 18.04 (64 bit)
- Compiler: g++ 7.3.0
- Debugger: gdb 8.1.0.20180409-git

#### Step

##### 1. 不含虚函数单继承

```c++
// 单继承，无虚函数
class Point2d
{
public:
    Point2d() = default;
private:
    float _x = 1.0;
    float _y = 2.0;
};

class Point3d : public Point2d
{
public:
    Point3d() : Point2d()
    {
    }
private:
    float _z = 3.0;
};

int main()
{
    Point2d p2;
    Point3d p3;
    cout << "size of Point2d: " << sizeof(p2) << endl;
    cout << "size of Point3d: " << sizeof(p3) << endl;
}
```

使用`g++ -std=c++11 -Wall -g    Test.cc   -o Test`编译，结果为：

![](https://raw.githubusercontent.com/plantree/plantree.github.io/master/images/20190605125355.png)

这个是合理的，因为每个`float`类型占据4个字节

在利用gdb调试之前，首先输入command便于之后调试

```gdb
set print pretty on
set print object on
set print vtbl on
```

内存布局如下：

![](https://raw.githubusercontent.com/plantree/plantree.github.io/master/images/20190605130615.png)

而观察内部的成员变量的地址分布是这样：

![](https://raw.githubusercontent.com/plantree/plantree.github.io/master/images/20190605130846.png)

因此很容易看出内存布局：

![](https://raw.githubusercontent.com/plantree/plantree.github.io/master/images/20190605132157.png)

子类内部包含一个基类，布局是先基类，后子类

#### 2. 带有虚函数的单继承

刚才的例子比较简单，简单成员函数不占据对象空间，但是虚函数则不同

```c++
// 单继承，有虚函数
class Point2d
{
public:
    Point2d() = default;
    virtual void print()
    {
    }
private:
    float _x = 1.0;
    float _y = 2.0;
};

class Point3d : public Point2d
{
public:
    Point3d() : Point2d()
    {
    }
    void print() override
    {
    }
private:
    float _z = 3.0;
};

int main()
{
    Point2d p2;
    Point3d p3;
    cout << "size of Point2d: " << sizeof(p2) << endl;
    cout << "size of Point3d: " << sizeof(p3) << endl;
}
```

结果有所变化:

![](https://raw.githubusercontent.com/plantree/plantree.github.io/master/images/20190605132812.png)

多了个虚函数，对象的大小增长了8（64bit系统的指针大小为8字节），可以先讲出原因，待会儿验证：增加了一个虚指针（virtual pointer），指向虚表（virtual table），虚表里存储的是虚函数。这是比较常见的解决虚函数继承的实现方案，无论多少个虚函数，对象的大小只会增加一个虚指针，在调用的时候多了一层间接访问，效率自然有所影响，但是好处是节约空间

gdb查看对象：

![](https://raw.githubusercontent.com/plantree/plantree.github.io/master/images/20190605133349.png)

会发现这里和上面测试的`sizeof`有些区别，`Point2d`增加一个虚指针后大小为16没有错，`Point3d`的大小应该是20才对，怎么会是24？这里涉及到**内存对齐**，因为虚指针排列在第一个位置，因此内存按照8对齐，就会在对象尾部填充一些字节，于是变成24。当然这是编译器为了提高性能而做的某种权衡，你也可以使用`#pragma pack(4)`来手动对齐

查看虚表的内容：

![](https://raw.githubusercontent.com/plantree/plantree.github.io/master/images/20190605133635.png)

也可以透过虚指针查看虚表的内容：

![](https://raw.githubusercontent.com/plantree/plantree.github.io/master/images/20190605135738.png)

借助`c++filt`查看经过`demangle`的函数名（这是用来解决函数重载的一种方法）

![](https://raw.githubusercontent.com/plantree/plantree.github.io/master/images/20190605140145.png)

有三点需要注意：

1. 虚指针指向的位置，也就是虚表存放的地址，与对象本身天差地远，这是以为虚表是一个类只有一份，并不存在于实例化的对象身上
2. 对于继承的父类的虚函数，如果没有覆盖（override），虚表里存放的函数指针依然指向父类原有的那个函数
3. 虚表里还存放着`type info`信息

对象中的内存布局也就比较清楚了，每个对象的起始位置增加了一个虚指针

![](https://raw.githubusercontent.com/plantree/plantree.github.io/master/images/20190605140706.png)

图示大体如下：

![](https://raw.githubusercontent.com/plantree/plantree.github.io/master/images/20190605141346.png)

#### 3. 多重继承

继承体系为：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606110043.png)

```c++
// 多重继承
class Point2d
{
public:
    Point2d() = default;
    virtual void print()
    {
    }
    virtual void get()
    {
    }
private:
    float _x = 1.0;
    float _y = 2.0;
};

class Point3d : public Point2d
{
public:
    Point3d() : Point2d()
    {
    }
    void get() override
    {
    }
    void put()
    {
    }
private:
    float _z = 3.0;
};

class Vertex : public Point2d
{
public:
    Vertex() : Point2d()
    {
        _next = nullptr;
    }
    void print() override
    {
    }
    virtual ~Vertex()
    {
        if (_next)
        {
            delete _next;
        }
    }
private:
    Vertex *_next;
};

class Vertex3d : public Point3d, public Vertex
{
public:
    Vertex3d() : Point3d(), Vertex()
    {
    }
private:
    float _xyz = 4.0;
};

int main()
{
    Point2d p2;
    Point3d p3;
    Vertex v;
    Vertex3d v3;
    cout << "size of Point2d: " << sizeof(p2) << endl;
    cout << "size of Point3d: " << sizeof(p3) << endl;
    cout << "size of Vertex: " << sizeof(v) << endl;
    cout << "size of Vertex3d: " << sizeof(v3) << endl;
}
```

查看对象大小：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606110652.png)

`Vertex3d`比较抽象，不过24+24+4+（4）=56，还是因为内存对齐，感觉是没错的，用gdb调试

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606111204.png)

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606110819.png)

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606110849.png)

查看虚表：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606111144.png)

可以看出来，`Vertex3d`完全包含了`Point3d`和`Vertex`的部分，而且内部虚指针有两个，`Point3d`的原有虚指针换成自己的名字，但是指向的内容没有变，`Vertex`的虚指针保持不变。而且可以看出，这里菱形继承，对于`Point2d`，p存在两份副本，无疑是浪费空间的。

简单看一下成员对象的地址分布：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606131016.png)

有个地方很奇怪，`_z`的位置竟然是在`_x`和`_y`的前面，因为`Point2d`有存在于两个地方，因此我怀疑这里输出的`_x`是`Vertex`中`Point2d`的部分，按照地址提取元素后发现：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606132424.png)

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606132129.png)

果然！`Point3d`中的`Point2d`部分还在，这样就能把对象的内存分布画出来了

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606132725.png)

#### 4. 虚继承

其实相比于多重继承，虚继承只不过是在中间两个对象继承最顶层基类的时候增加了`virtual`关键字而已，其他变化不大

```c++
class Point3d : virtual public Point2d
{
public:
    Point3d() : Point2d()
    {
    }
    void get() override
    {
    }
    void put()
    {
    }
private:
    float _z = 3.0;
};

class Vertex : virtual public Point2d
{
public:
    Vertex() : Point2d()
    {
        _next = nullptr;
    }
    void print() override
    {
    }
    virtual ~Vertex()
    {
        if (_next)
        {
            delete _next;
        }
    }
private:
    Vertex *_next;
};
```

结果又有所变化

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606132957.png)

对象`Point2d`和`Vertex`大小增加了8，猜测是增加了一个指针，下面具体看看增加了什么

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606133212.png)

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606133326.png)

这个变化，不可谓不大，我们知道虚拟继承，可以用来解决`shared subobject`继承问题，对照这里的菱形继承，保证`Point2d`对象只有一份，减少冗余存储。看结果也是，`Vertex`类中的`Point2d`部分已经消失，那是怎么做到的呢?

同时意识到，虽然`Vertex3d`对象大小还是56，但是计算的方法已经变了（减少一个`Point2d`，但是也增加了一些指针）

查看虚表：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606134030.png)

有些费解

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606135920.png)

清楚一些，大体推测是先排列`Point3d`和`Vertex`，最后排列`Point2d`

说实话有些一筹莫展，看网上的一个博客知道用`-fdump-class-hierarchy`编译后可以得到一个`.class`文件，查看文件内容大体如下：

```
Vtable for Vertex3d
Vertex3d::_ZTV8Vertex3d: 18 entries
0     40
8     (int (*)(...))0
16    (int (*)(...))(& _ZTI8Vertex3d)
24    (int (*)(...))Point3d::get
32    (int (*)(...))Vertex3d::~Vertex3d
40    (int (*)(...))Vertex3d::~Vertex3d
48    24
56    (int (*)(...))-16
64    (int (*)(...))(& _ZTI8Vertex3d)
72    (int (*)(...))Vertex::print
80    (int (*)(...))Vertex3d::_ZThn16_N8Vertex3dD1Ev
88    (int (*)(...))Vertex3d::_ZThn16_N8Vertex3dD0Ev
96    18446744073709551576
104   18446744073709551592
112   (int (*)(...))-40
120   (int (*)(...))(& _ZTI8Vertex3d)
128   (int (*)(...))Vertex::_ZTv0_n24_N6Vertex5printEv
136   (int (*)(...))Point3d::_ZTv0_n32_N7Point3d3getEv

Construction vtable for Point3d (0x0x7f54c6702958 instance) in Vertex3d
Vertex3d::_ZTC8Vertex3d0_7Point3d: 10 entries
0     40
8     (int (*)(...))0
16    (int (*)(...))(& _ZTI7Point3d)
24    (int (*)(...))Point3d::get
32    18446744073709551576
40    0
48    (int (*)(...))-40
56    (int (*)(...))(& _ZTI7Point3d)
64    (int (*)(...))Point2d::print
72    (int (*)(...))Point3d::_ZTv0_n32_N7Point3d3getEv

Construction vtable for Vertex (0x0x7f54c67029c0 instance) in Vertex3d
Vertex3d::_ZTC8Vertex3d16_6Vertex: 12 entries
0     24
8     (int (*)(...))0
16    (int (*)(...))(& _ZTI6Vertex)
24    (int (*)(...))Vertex::print
32    0
40    0
48    0
56    18446744073709551592
64    (int (*)(...))-24
72    (int (*)(...))(& _ZTI6Vertex)
80    (int (*)(...))Vertex::_ZTv0_n24_N6Vertex5printEv
88    (int (*)(...))Point2d::get

VTT for Vertex3d
Vertex3d::_ZTT8Vertex3d: 7 entries
0     ((& Vertex3d::_ZTV8Vertex3d) + 24)
8     ((& Vertex3d::_ZTC8Vertex3d0_7Point3d) + 24)
16    ((& Vertex3d::_ZTC8Vertex3d0_7Point3d) + 64)
24    ((& Vertex3d::_ZTC8Vertex3d16_6Vertex) + 24)
32    ((& Vertex3d::_ZTC8Vertex3d16_6Vertex) + 80)
40    ((& Vertex3d::_ZTV8Vertex3d) + 128)
48    ((& Vertex3d::_ZTV8Vertex3d) + 72)
```

比我想的复杂很多，多重虚继承，编译器在背后默默的真的是做了很多的工作......

《深度探索C++对象模型》p120-122页说的很对，g++的实现策略是第二个，和微软的实现不同，将一个距离虚基类的偏移量放入虚表中，如果索引到的是负值，那么就要通过偏移，找到最原始基类，也就是`Point2d`的虚表，否则就直接命中虚函数

内存布局大体如下：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190606150228.png)

相关代码都在这里[Github](https://github.com/plantree/Practice)

#### Thinking：

没想到C++的对象模型这么复杂，当初看书的时候觉得理解的还可以，花了整整两天的时间才大致整理出来，但还有一些细节不甚了解。编译器在背后，的确是做了不少的贡献，而且把如此抽象复杂的实现封装的这么好，用的完全意识不到，看来自己还是`too naive`。这个世界是复杂的，简单一致的表象背后，是一套精密、高效的运作机制。无论如何，请保持谦虚，尽管有些事情，本来就很难，但是做到了，就很酷！

> The devil is in the details

#### Reference：

- 《深度探索C++对象模型》

- https://qinglinmao8315.github.io/c++/2018/02/28/c++-vtable-in-virtual-inheritance.html

  