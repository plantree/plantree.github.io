---
layout: post
title: muduo源码探索 (二十四)
categories: [muduo]
description: muduo源码探索-TcpConnection
keywords: muduo, network, 网络
---

`TcpConnection`类用于表示一次连接，其重要性不言而喻。对于`TcpServer`或者是`TcpClient`而言，两者都是静态的类，全局的生命周期，只要负责连接的建立和断开即可。但是对于我们而言，连接建立只是第一步，怎么使用这些连接才是最重要的。也看得出，`TcpConnection`是一个动态的类，有连接的时候才会或者，而是每一个连接都对应者一个`TcpConnection`类。我们的所有故事，也都是从这个类开始展开：处理的就是每个连接上的事件。这个类还有个很大的难题，就是生命周期很模糊，必须保证这个类在连接建立前夕创建，在连接关闭后就要销毁。看看怎么处理吧。

#### TcpConnection

##### 1. 任务

- 实现一个维护连接的类，一个连接，对应一个实例

##### 2. 实现

这个类在`TcpServer`和`TcpClient`中都存在，不同的是，`TcpServer`中存在很多个，但是`TcpClient`中却只有一个。两者不存在一个对应关系，各自拥有各自的一个`TcpConnection`

```c++
// Tcp connection, for both client and server usage
// This is an interface class, so don't expose too much details
class TcpConnection : noncopyable,
                    public std::enable_shared_from_this<TcpConnection> // 在类的内部获取shared_ptr
{
public:
    // construct a TcpConnection with a connected sockfd
    TcpConnection(EventLoop *loop,
                    const string &name,
                    int sockfd,
                    const InetAddress &localAddr,
                    const InetAddress &peerAddr);
    ~TcpConnection();

    EventLoop *getLoop() const 
    {
        return loop_;
    }

    const string &name() const 
    {
        return name_;
    }

    const InetAddress &localAddress()
    {
        return localAddr_;
    }

    const InetAddress &peerAddress()
    {
        return peerAddr_;
    }

    bool connected() const 
    {
        return state_ == kConnected;
    }

    bool disconnetected() const 
    {
        return state_ == kDisconnected;
    }

    // return true if success
    bool getTcpInfo(struct tcp_info *) const;
    string getTcpInfoString() const;

    void send(const void *message, int len);
    void send(const StringPiece &message);
    void send(Buffer *message);

    void shutdown();    // not thread safe, no simultaneous calling
    
    void forceClose();
    void forceCloseWithDelay(double seconds);
    
    void setTcpNoDelay(bool on);

    void startRead();
    void stopRead();
    bool isReading() const 
    {
        return reading_;
    }

    // FIXME: any context

    // 回调函数：连接、读事件、写完成事件、高水位事件
    void setConnectionCallback(const ConnectionCallback &cb)
    {
        connectionCallback_ = cb;
    }

    void setMessageCallback(const MessageCallback &cb)
    {
        messageCallback_ = cb;
    }

    void setWriteCompleteCallback(const WriteCompleteCallback &cb)
    {
        writeCompleteCallback_ = cb;
    }

    void setHightWaterMarkCallback(const HighWaterMarkCallback &cb, size_t highWaterMark)
    {
        highWaterMarkCallback_ = cb;
        highWaterMark_ = highWaterMark;
    }

    // advance interface
    Buffer *inputBuffer()
    {
        return &inputBuffer_;
    }
    Buffer *outputBuffer()
    {
        return &outputBuffer_;
    }

    // Internal use only
    // 关闭时回调
    void setCloseCallback(const CloseCallback &cb)
    {
        closeCallback_ = cb;
    }

    // called when TcpServer accepts a new connection
    void connectEstablished();  // should be called only once
    // called when TcpServer has removed me from its map
    void connectDestroyed();
    
private:
    enum StateE { kDisconnected, kConnecting, kConnected, kDisconnecting};
    
    void handleRead(Timestamp receiveTime);
    void handleWrite();
    void handleClose();
    void handleError();

    void sendInLoop(const StringPiece &message);
    void sendInLoop(const void *message, size_t len);
    
    void shutdownInLoop();
    void forceCloseInLoop();
    void setState(StateE s)
    {
        state_ = s;
    }
    const char *stateToString() const;
    void startReadInLoop();
    void stopReadInLoop();

    EventLoop *loop_;
    const string name_;
    StateE state_;  // FIXME: use atomic variable
    bool reading_;

    // we don't expose those classes to client
    std::unique_ptr<Socket> socket_;
    std::unique_ptr<Channel> channel_;
    
    InetAddress localAddr_;
    InetAddress peerAddr_;

    ConnectionCallback connectionCallback_;
    MessageCallback messageCallback_;
    // 数据发送完毕回调函数，就是所有的用户数据都拷贝到内核缓冲区，
    // outputBuffer_被清空也会回调该函数，可理解为低水位回调函数
    WriteCompleteCallback writeCompleteCallback_;
    HighWaterMarkCallback highWaterMarkCallback_;   // 高水位标回调函数
    CloseCallback closeCallback_;

    size_t highWaterMark_;
    Buffer inputBuffer_;
    Buffer outputBuffer_;
};
```

看头文件，就知道这个类有多复杂，构造函数接收五个参数，一个`EventLoop`指针（这个都少不了），一个名字（不是很重要），一个套接字文件描述符，很容易猜到这就是连接套接字，一个本地IP地址，一个对方IP地址。功能是，可以发送消息，使用`send()`，也可以接收消息，使用`startRead()`，还有一些额外的操作，比如说强制关闭，设置TCP的一些选项。最主要的，是一些事件回调，有连接、读、写完成、高水位、关闭事件。另外两个函数，是在连接建立和销毁的时候调用的。

内部还有两个之前实现的，用户空间缓冲区，用户的发送和接收，其实都是和这两个用户空间缓冲区打交道。之所以自己额外实现缓冲区，原因很明显，就是更好的管理消息，提高使用的弹性，用户只管写入或者读取，而不去管何时会递交到内核缓冲区，这些都交给用户空间缓冲区来处理。

至于连接状态，大体有四个，失去连接、正在连接、已经连接和正在失去连接。

内部的成员，有一个`Socket`，是关于连接套接字，一个`Channel`，用于管理套接字上的各种事件，两个地址，对应着一条连接。

```c++
// 默认连接回调
void slack::net::defaultConnectionCallback(const TcpConnectionPtr &conn)
{
    LOG_TRACE << conn->localAddress().toIpPort() << "->"
            << conn->peerAddress().toIpPort() << " is "
            << (conn->connected() ? "UP" : "DOWN");
}

// 默认读事件回调
void slack::net::defaultMessageCallback(const TcpConnectionPtr &conn, 
                                        Buffer *buf, 
                                        Timestamp)
{
    buf->retrieveAll();
}
```

实现了两个默认的回调函数，一个是默认连接，只是输出内容，一二是默认消息到来回调，直接清空。

```c++
// 默认连接回调
void slack::net::defaultConnectionCallback(const TcpConnectionPtr &conn)
{
    LOG_TRACE << conn->localAddress().toIpPort() << "->"
            << conn->peerAddress().toIpPort() << " is "
            << (conn->connected() ? "UP" : "DOWN");
}

// 默认读事件回调
void slack::net::defaultMessageCallback(const TcpConnectionPtr &conn, 
                                        Buffer *buf, 
                                        Timestamp)
{
    buf->retrieveAll();
}
```

```c++
// ctor
TcpConnection::TcpConnection(EventLoop *loop,
                            const string &nameArg,
                            int sockfd,
                            const InetAddress &localAddr,
                            const InetAddress &peerAddr)
    : loop_(CHECK_NOTNULL(loop)),
    name_(nameArg),
    state_(kConnecting),
    socket_(new Socket(sockfd)),
    channel_(new Channel(loop, sockfd)),
    localAddr_(localAddr),
    peerAddr_(peerAddr),
    highWaterMark_(64 * 1024 * 1024)
{
    // Channel可读事件到来，回调handleRead
    channel_->setReadCallback(std::bind(&TcpConnection::handleRead, this, _1));
    // 读通道可写事件到达
    channel_->setWriteCallback(std::bind(&TcpConnection::handleWrite, this));
    // 连接关闭，回调handleClose
    channel_->setCloseCallback(std::bind(&TcpConnection::handleClose, this));
    // 发生错误，回调handleError
    channel_->setErrorCallback(std::bind(&TcpConnection::handleError, this));
    
    LOG_DEBUG << "TcpConnection::ctor[" << name_ << "] at " << this 
            << " fd = " << sockfd;
    // 设置为保持连接
    socket_->setKeepAlive(true);
}

TcpConnection::~TcpConnection()
{
    LOG_DEBUG << "TcpConnection::dtor[" << name_ << "] at " << this
            << " fd = " << channel_->fd()
            << " state = " << stateToString();
    assert(state_ == kDisconnected);
}
```

构造函数做了很多事情，先将状态标记为`kConnecting`，同时根据连接套接字建立`Socket`以及负责监听的`Channel`，高水位标记也可以设置，最主要的，就是设置`Channel`的一些回调函数，比如可读事件、可写事件、连接关闭的事件以及错误的处理，而`Socket`的属性则为`保活`，对于长连接很重要，会定期发送探测包（类似于心跳），如果对端关闭连接，会触发套接字的可读事件，同时`recv`的返回值为-1，并设置`errno`为`ETIMEOUT`。

对于析构函数而言，因为内部成员的生存期不归它管理，因此基本上啥都没做，但是应该保证连接状态已经是断开连接，否则会出现一些问题。

发送数据，使用的是`send`函数，虽然有几个，但是内部的实现手段是相似的，首先是在连接已经建立的前提下，而且要放在IO线程中执行，最后调用的是`sendInLoop`，开始写的时候如果`Channel`还没有监听可写事件，并且输出缓冲区是空的，就使用`write`直接写，否则就要放入输出缓冲区。写的话如果写完，就执行写完的回调，也是在IO线程中进行，否则的话就要进行错误判断。如果没有错误，而且数据没有写完，说明可能TCP输入缓冲区已经满了，就放入用户空间的缓冲区，如果缓冲区数据太多，就会触发高水位事件回调。此时，如果`Channel`没有监听可写事件，那么就要让它监听，因为输出缓冲区已经有数据需要发送，等待套接字可写。

```c++
void TcpConnection::shutdown()
{
    if (state_ == kConnected)
    {
        setState(kDisconnecting);
        // FIXME: shard_from_this()?
        loop_->runInLoop(std::bind(&TcpConnection::shutdownInLoop, this));
    }
}

void TcpConnection::shutdownInLoop()
{
    loop_->assertInLoopThread();
    if (!channel_->isWriting())
    {
        socket_->shutdownWrite();
    }
}

void TcpConnection::forceClose()
{
    if (state_ == kConnected || state_ == kDisconnecting)
    {
        setState(kDisconnecting);
        loop_->queueInLoop(std::bind(&TcpConnection::forceCloseInLoop, shared_from_this()));
    }
}

void TcpConnection::forceCloseWithDelay(double seconds)
{
    if (state_ == kConnected || state_ == kDisconnecting)
    {
        setState(kDisconnecting);
        loop_->runAfter(
            seconds,
            makeWeakCallback(shared_from_this(),
                                &TcpConnection::forceClose));   // not forceCloseInLoop to avoid
                                                                // race condition
    }
}

void TcpConnection::forceCloseInLoop()
{
    loop_->assertInLoopThread();
    if (state_ == kConnected || state_ == kDisconnecting)
    {
        // as if we received 0 byte in handleRead()
        handleClose();
    }
}
```

关闭连接的方式有好几个，比如`shutdown`和`close`。对于`shutdown()`而言，最终是在IO线程中让`Socket`执行写的半关闭（仍然可读，但是不可写）。对于`forceClose`而言，是强制关闭，最终执行的是关闭的回调。

```c++
void TcpConnection::startRead()
{
    loop_->runInLoop(std::bind(&TcpConnection::startReadInLoop, this));
}

void TcpConnection::startReadInLoop()
{
    loop_->assertInLoopThread();
    if (!isReading() || !channel_->isReading())
    {
        channel_->enableReading();
        reading_ = true;
    }
}

void TcpConnection::stopRead()
{
    loop_->runInLoop(std::bind(&TcpConnection::stopReadInLoop, this));
}

void TcpConnection::stopReadInLoop()
{
    loop_->assertInLoopThread();
    if (reading_ || channel_->isReading())
    {
        channel_->disableReading();
        reading_ = false;
    }
}
```

对于读而言，区分开始读和结束读。开始读就是设置`Channel`的读事件，并将`reading_`标记为`true`。而对于结束读，则是相反的动作，取消`Channel`的监听，同时标记`reading_`状态为`false`。

```c++
void TcpConnection::connectEstablished()
{
    loop_->assertInLoopThread();
    assert(state_ == kConnecting);
    setState(kConnected);
    // 增加智能指针引用技术，保证比Channel的存活时间久
    // 已经有一个share_ptr被构建，放在TcpServer的map里
    // enable_shared必须之前已经有现成的shared_ptr
    channel_->tie(shared_from_this());
    channel_->enableReading();  // 对应Channel加入到Poller监听

    connectionCallback_(shared_from_this());
}

void TcpConnection::connectDestroyed()
{
    loop_->assertInLoopThread();
    if (state_ == kConnected)
    {
        setState(kDisconnected);
        channel_->disableAll();

        connectionCallback_(shared_from_this());
    }
    // 从Poller监听中移除
    channel_->remove();
}
```

连接的建立和销毁是两个很重要的事件，连接建立，这个时候说明`TcpConnection`对象已经建立，此时特别注意，让`Channel`弱引用该对象，同时监听可读事件，并执行连接建立回调。之所以使用弱引用，是要`Channel`的临时延长`TcpConnection`的生命期，避免`TcpConnection`对象都已经销毁，`Channel`还在监听事件，就没有回调的对象了。

而对于连接的销毁，就是解除`Channel`的事件监听，并且从`Poller`中移除，同时执行连接回调。

```c++
void TcpConnection::handleRead(Timestamp receiveTime)
{
    loop_->assertInLoopThread();
    int savedErrno = 0;
    ssize_t n = inputBuffer_.readFd(channel_->fd(), &savedErrno);
    if (n > 0)
    {
        messageCallback_(shared_from_this(), &inputBuffer_, receiveTime);
    }
    else if (n == 0)
    {
        handleClose();
    }
    else 
    {
        errno = savedErrno;
        LOG_ERROR << "TcoConnection::handleRead";
        handleError();
    }
}

// 内核发送缓冲区有空间，回调该函数
void TcpConnection::handleWrite()
{
    loop_->assertInLoopThread();
    if (channel_->isWriting())
    {
        ssize_t n = sockets::write(channel_->fd(),  
                                    outputBuffer_.peek(),
                                    outputBuffer_.readableBytes());
        if (n > 0)
        {
            outputBuffer_.retrieve(n);
            // 发送区缓冲区清空
            if (outputBuffer_.readableBytes() == 0)
            {
                // 及时关闭写事件
                channel_->disbaleWriting(); // 停止关注POLLOUT，避免busy loop
                if (writeCompleteCallback_)
                {
                    loop_->queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));
                }
                if (state_ == kDisconnecting)
                {
                    shutdownInLoop();   // 关闭连接
                }
            }
        }
        else 
        {
            LOG_SYSERR << "TcpConnection::handleWrite";
        }
    }
    else 
    {
        LOG_TRACE << "Connection fd = " << channel_->fd()
                << " is down, no more writing";
    }
}


void TcpConnection::handleClose()
{
    loop_->assertInLoopThread();
    LOG_TRACE << "fd = " << channel_->fd() << " state = " << state_;
    assert(state_ == kConnected || state_ == kDisconnecting);
    // we don't close fd, leave it to dtor
    setState(kDisconnected);
    channel_->disableAll();

    TcpConnectionPtr guardThis(shared_from_this());
    connectionCallback_(guardThis);
    closeCallback_(guardThis);
}

void TcpConnection::handleError()
{
    int err = sockets::getSocketError(channel_->fd());
    LOG_ERROR << "TcpConnection::handleError [" << name_
        << "] - SO_ERROR = " << err << " " << strerror_tl(err);
}
```

最后的四个，是事件到来时触发的回调函数，传递给`Channel`，都是在IO线程中调用。对于读事件，就是从用户空间中读数据，读到的话，就执行`messageCallback_`回调，这个函数是从上层传递过来的。如果没有读到，或是错误，就有相应的处理函数。

写事件的处理有些技巧，直接从应用层输出缓冲区拿出数据，写入内核缓冲区，如果输出缓冲区空了，说明没有数据可写，那么就关闭`Channel`的写事件监听。如果有写完回调，就执行，如果状态是正在失去连接，那么就半关闭写，只负责读了。

对于关闭的处理，就是断开连接，取消`Channel`的监听，同时执行关闭的回调函数。

对于错误的处理更直接，直接借用`Socket`的成员函数取得错误结果。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

`TcpConnection`是对一次连接的抽象，代码比较多，也比较复杂，设计的知识点琐碎而又密集 更主要的，是这个类上的事件很多，读、写、关闭、错误等，而且生命期模糊而不确定，尤其是在多线程环境下，有的时候还需要临时的提升对象的生命期，避免提前消亡，否则执行回调的时候发现原始对象已经没了，问题就很大。这里只是说了`TcpConnection`的内部实现，后面会有具体的使用。

#### 参考：

- 《Linux多线程服务端编程》
- 《Linux/Unix系统编程手册》
