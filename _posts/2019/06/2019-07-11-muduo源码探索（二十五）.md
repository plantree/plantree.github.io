---
layout: post
title: muduo源码探索 (二十五)
categories: [muduo]
description: muduo源码探索-TcpServer
keywords: muduo, network, 网络
---

上一次先说了`TcpConnection`，但是不知道怎么使用，因为是内部成员对象，不暴露出去。之前的所有所有，都是故事背后的人物，从底层开始搭建，现在终于要浮出水面，拨云见日。有两个类，`TcpServer`和`TcpClient`，两个类都是直接暴露给用户的，对应着服务端和客户端，使用方式有些差异。

#### TcpServer

##### 1. 任务

- 实现一个服务器，处理各种连接事件

##### 2. 实现

这个类是相当重要的，因为网络库，其实说到底就是要实现一个能够处理各种连接到来，并且服务的服务端。而且我们的`Reactor`模型，以及one loop per thread，都是针对服务端而来的。

看注释也知道，这里的`TcpServer`既支持单线程，也支持线程池模型。

```c++
// Tcp Server, supports single-threaded and thread-pool models
// This is an interface class, so don't expose too much details
class TcpServer : noncopyable
{
public:
    using ThreadInitCallback = std::function<void (EventLoop*)>;
    enum Option
    {
        kNoReusePort,
        kReusePort
    };

    TcpServer(EventLoop *loop,
                const InetAddress &listenAddr,
                const string &nameArg,
                Option option = kNoReusePort);
    ~TcpServer();

    const string &ipPort() const 
    {
        return ipPort_;
    }

    const string &name() const 
    {
        return name_;
    }

    EventLoop *getLoop() const 
    {
        return loop_;
    }

    // set the number of threads for handling input
    // always accepts new connection in loop's thread
    void setThreadNum(int numThreads);
    void setThreadInitCallback(const ThreadInitCallback &cb)
    {
        threadInitCallback_ = cb;
    }

    // valid after calling start()
    std::shared_ptr<EventLoopThreadPool> threadPool()
    {
        return threadPool_;
    }

    // starts the server if it's not listenning
    // it's harmless to call if multiple times
    void start();

    // set connection callback, not thread safe
    void setConnectionCallbck(const ConnectionCallback &cb)
    {
        connectionCallback_ = cb;
    }

    // set message callback, not thread safe
    void setMessageCallback(const MessageCallback &cb)
    {
        messageCallback_ = cb;
    }

    // not thread safe
    void setWriteCompleteCallback(const WriteCompleteCallback &cb)
    {
        writeCompleteCallback_ = cb;
    }
private:
    // Not thread safe, but in loop
    void newConnection(int sockfd, const InetAddress &peerAddr);
    // thread safe
    void removeConnection(const TcpConnectionPtr &conn);
    // not thread safe, but in loop
    void removeConnectionInLoop(const TcpConnectionPtr &conn);

    typedef std::map<string, TcpConnectionPtr> ConnectionMap;

    EventLoop *loop_;   // the acceptor loop
    const string ipPort_;
    const string name_;

    std::unique_ptr<Acceptor> acceptor_;
    std::shared_ptr<EventLoopThreadPool> threadPool_;
    
    ConnectionCallback connectionCallback_;
    MessageCallback messageCallback_;
    WriteCompleteCallback writeCompleteCallback_;   // 数据发送完毕回调函数
    ThreadInitCallback threadInitCallback_;
    
    AtomicInt32 started_;
    // always in loop thread
    int nextConnId_;
    ConnectionMap connections_;

};
```

这个类也是够复杂的，也难怪，毕竟已经是我们最后的任务，就是将之前实现的各种类拼装。构造函数中有一个`EventLoop`，作为主loop，监听地址是为内部的`Acceptor`服务的。依然要设置一些回调函数，比如连接、消息到达，写完事件，都是传递给内部的`TcpConnection`。

内部的一些成员需要关注一下，首先有一个`EventLoop`，一个`Acceptor`，还有个`EventLoop`线程池，也就是多个副`Reactor`，下一个连接id使用的就是`Round-robin`轮询，`ConnectionMap`比较重要，将连接的名字和连接映射，维护的是当前的所有连接。

```c++
TcpServer::TcpServer(EventLoop *loop,
                    const InetAddress &listenAddr,
                    const string &nameArg,
                    Option option)
    : loop_(CHECK_NOTNULL(loop)),
    ipPort_(listenAddr.toIpPort()),
    name_(nameArg),
    acceptor_(new Acceptor(loop, listenAddr, option == kReusePort)),
    threadPool_(new EventLoopThreadPool(loop, name_)),
    connectionCallback_(defaultConnectionCallback),
    messageCallback_(defaultMessageCallback),
    nextConnId_(1)
{
    // Acceptor::handleRead回调TcpServer::newConnection
    // _1对应socket文件描述符，_2对应peerAddress
    acceptor_->setNewConnectionCallback(std::bind(&TcpServer::newConnection, this, _1, _2));
}

TcpServer::~TcpServer()
{
    loop_->assertInLoopThread();
    LOG_TRACE << "TcpServer::~TcpServer [" << name_ << "] destructing";

    for (auto &it : connections_)
    {
        // 多一次引用
        TcpConnectionPtr conn = it.second;
        // 释放当前控制资源，减少一次引用计数
        it.second.reset();
        conn->getLoop()->runInLoop(std::bind(&TcpConnection::connectDestroyed, conn));
        conn.reset();  
    }
}
```

构造函数主要是新建一个`Acceptor`，一个`EventLoop`线程池，设置连接回调和消息回调为默认，`nextConnId_`从1开始，并设置`Accpetor`接收连接后的回调函数。

析构函数，其实主要就是析构所有的`TcpConnection`对象，在各自对应的IO线程中执行断开连接的操作。

```c++
void TcpServer::setThreadNum(int numThreads)
{
    assert(numThreads >= 0);
    threadPool_->setThreadNum(numThreads);
}

// 可以多次调用，跨线程也可以
void TcpServer::start()
{
    // 只能开始一次
    if (started_.getAndSet(1) == 0)
    {
        // 启动线程池
        threadPool_->start(threadInitCallback_);

        // 开始监听
        assert(!acceptor_->listenning());
        loop_->runInLoop(std::bind(&Acceptor::listen, get_pointer(acceptor_)));
    }
}
```

设置线程的个数，其实就是`EventLoop`线程池的中线程的个数，也就是副`Reactor`的个数。`TcpServer`服务的启动，只能启动一个主`Reactor`，同时启动线程池，并开始监听。

```c++
void TcpServer::newConnection(int sockfd, const InetAddress &peerAddr)
{
    loop_->assertInLoopThread();
    // 轮询选择下一个
    EventLoop *ioLoop = threadPool_->getNextLoop();
    char buf[64];
    snprintf(buf, sizeof buf, "-%s#%d", ipPort_.c_str(), nextConnId_);
    ++nextConnId_;
    string connName = name_ + buf;

    LOG_INFO << "TcpServer::newConnection [" << name_
            << "] - new connection [" << connName
            << "] from " << peerAddr.toIpPort();
    InetAddress localAddr(sockets::getLocalAddr(sockfd));

    // 创建连接
    TcpConnectionPtr conn(new TcpConnection(ioLoop,
                                            connName,
                                            sockfd,
                                            localAddr,
                                            peerAddr));
    connections_[connName] = conn;
    // 设置回调
    conn->setConnectionCallback(connectionCallback_);
    conn->setMessageCallback(messageCallback_);
    conn->setWriteCompleteCallback(writeCompleteCallback_);
    conn->setCloseCallback(std::bind(&TcpServer::removeConnection, this, _1));

    ioLoop->runInLoop(std::bind(&TcpConnection::connectEstablished, conn));
}

void TcpServer::removeConnection(const TcpConnectionPtr &conn)
{
    loop_->runInLoop(std::bind(&TcpServer::removeConnectionInLoop, this, conn));
}

void TcpServer::removeConnectionInLoop(const TcpConnectionPtr &conn)
{
    loop_->assertInLoopThread();
    LOG_INFO << "TcpServer::removeConnectionInLoop [" << name_
            << "] - connection " << conn->name();

    size_t n = connections_.erase(conn->name()); (void)n;
    assert(n == 1);

    EventLoop *ioLoop = conn->getLoop();
    ioLoop->queueInLoop(std::bind(&TcpConnection::connectDestroyed, conn));
}
```

接下来就要处理新的连接以及连接断开的情况。`newConnection`是作为回调函数传递给`Acceptor`，每当有连接到来，就从线程池中按照`round-robin`的方式选择下一个，创建一个新的连接，连接内部的`EventLoop`就是选择的那个线程，也是该连接的IO线程，放在`map`中，同时设置`TcpConnection`的各种回调函数，它的IO线程就会执行连接已经建立的函数，那么接下来关于这条连接的所有操作，就委托给另一个线程，主线程就负责接受连接，然后`dispatcher`。

对于移除连接而言，一定要在主线程中，因为主`Reactor`中有所有连接的信息。移除连接，首先就把连接从`map`中移除，然后在连接自身的IO线程中执行关闭连接的操作。

这就是多线程版本的`Reactor`模型，one loop per thread以及thread pool。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

`TcpServer`是网络库应用层面的核心，内部包裹了很多我们之前封装过的类，有了那些基础的类，拼装实现更高层的应用就变得相对简单。但是尽管如此，各种事件的处理，回调函数的使用，依然不是一件很容易的事情，尽管照着写完，但是明显的感觉到有很多具体的细节理解的不是很到位，后面应该还会再看看。

#### 参考：

- 《Linux多线程服务端编程》
- 《Linux/Unix系统编程手册》
