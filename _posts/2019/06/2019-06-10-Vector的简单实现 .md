---
layout: post
title: Vector的简单实现
categories: [C++]
description: Vector的简单实现
keywords: C++, practice
---

《C++ Primer》书中有个模板`Vector`的简单实现，利用到了底层的`std::allocator`内存分配器。整个代码思路清楚，包括`Vector`的移动拷贝，移动赋值，以及在`push_back`过程中，底层内存的动态扩展，不是特别难，很有意思，而且的确能用。

#### Goal

- 实现`Vector`模板类，实现基本的成员函数，实现移动语义，底层内存空间自动管理扩展、元素拷贝和销毁

#### Environment

- OS： ubuntu 18.04 (64 bit)
- Compiler: g++ 7.3.0

#### Step

#####　1. 实现

类图如下：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190610162103.png)

内部有个`std::allocator`，负责底层内存的获取、释放，以及对象的建立、销毁。剩下的三个指针，就维护着`Vector`模型。

简单画了一下：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190611131019.png)

`private`的几个函数，并不对外部开放，因为要将内存管理的复杂性保留在类的内部。使用者完全不必关注是如何实现的。先来看看内存的管理。

```c++
// utility function
template <typename T>
inline 
std::pair<T *, T *> 
Vector<T>::alloc_copy(const T *b, const T *e)
{
    auto newdata = alloc.allocate(e - b);
    // {first, end}
    return {newdata, std::uninitialized_copy(b, e, newdata)};
}

template <typename T>
void Vector<T>::free()
{
    // destroy elements in reverse order
    for (auto b = first_free; b != elements; alloc.destroy(--b))
    {
    }

    // cannot be nullptr
    if (elements)
    {
        alloc.deallocate(elements, cap-elements);
    }
}

template <typename T>
void Vector<T>::reallocate()
{
    auto newcapacity = size() ? 2 * size() : 1;
    
    // allocate new space
    auto first = alloc.allocate(newcapacity);
    // new start
    auto dest = first;
    // old start
    auto elem = elements;

    // move the elements
    size_t sz = size();
    for (size_t i = 0; i != sz; ++i)
    {
        alloc.construct(dest++, std::move(*elem++));
    }
    free();
    
    // update pointer
    elements = first;
    first_free = dest;
    cap = elements + newcapacity;
}
```

主要的三个函数，分别负责内存的分配和拷贝复制，一个负责内存资源的释放，还有一个是负责重新的分配，尤其是对于`push_back`等操作：原有的空间不够用，就要额外申请一个更大的内存区域，同时把旧的数据全部拷贝。

内存的分配和拷贝不困难，直接调用`allocate()`函数申请一片原始内存，同时利用`std::unintialized_copy()`用于在未初始化内存中复制对象，对象的建立，就分为内存申请，和对象构造两个独立的阶段，返回的是首位两个指针位置。

释放的操作代码也比较清楚，首先逆序的将对象销毁，然而此时内存并没有被释放，要调用`deallocate()`将内存归还。

重新分配内存比较复杂，按照标准库的实现逻辑，按照二倍的速度指数增长，GNU C++是两倍，VC++是1.5倍。之所以一次性增长那么多，应该还是为了摊还时间上的消耗，如果每增加一个元素，就多分配一个空间，时间消耗必然很多。倍数关系的话，照我的理解，应该还是要取得时间和空间的一个平衡，刚才说了太小不好，太大的话会浪费空间，而且二倍的关系可以通过移位计算，比较方便。首先肯定是先分配一个更大的空间，使用`allocate()`，然后将旧元素搬移到新的位置，释放旧有内存，将指针更新为新的位置。思路清楚。

`Vector`的类，实现了`Big-5`，很经典的实现。

```c++
template <typename T>
inline
Vector<T>::Vector(std::initializer_list<T> il)
{
    auto newdata = alloc_copy(il.begin(), il.end());
    elements = newdata.first;
    first_free = cap = newdata.second;
}

template <typename T>
inline
Vector<T>::Vector(const Vector &rhs)
{
    // allocate space
    auto newdata = alloc_copy(rhs.begin(), rhs.end());
    elements = newdata.first;
    first_free = cap = newdata.second;
}

template <typename T>
inline 
Vector<T>::Vector(Vector &&rhs) noexcept
    : elements(rhs.elements), first_free(rhs.first_free), cap(rhs.cap)
{
    rhs.elements = rhs.first_free = rhs.cap = nullptr;
}

template <typename T>
inline
Vector<T> &Vector<T>::operator=(const Vector &rhs)
{
    // avoid self-assignment
    if (this != &rhs)
    {
        auto newdata = alloc_copy(rhs.begin(), rhs.end());
        // free old data
        free();
        elements = newdata.first;
        first_free = cap = newdata.second;
    }
    return *this;
}

template <typename T>
inline
Vector<T> &Vector<T>::operator=(Vector &&rhs) noexcept
{
    if (this != &rhs)
    {
        free();
        // stole resources
        elements = rhs.elements;
        first_free = rhs.first_free;
        cap = rhs.cap;

        // leave rhs in a destructible state
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}

template <typename T>
inline
Vector<T> &Vector<T>::operator=(std::initializer_list<T> il)
{
    auto newdata = alloc_copy(il.begin(), il.end());
    free();
    elements = newdata.first;
    first_free = cap = newdata.second;
    return *this;
}

template <typename T>
inline 
Vector<T>::~Vector() noexcept 
{
    free();
}
```

首先可以接收一个`initializer_list`的构造函数，也就是实现了`{}`初始化，过程与拷贝构造几乎一样，借助上面已经实现的`alloc_copy`私有成员函数很容易实现。移动构造的语义，其实就是用指针接管右值内部的指针，同时将其指针赋值为空，避免误用。拷贝赋值和移动赋值都需要考虑自赋值的情况，与移动赋值不同，拷贝赋值需要重新分配空间，而移动赋值则只是指针的移动，很方便，析构函数更简单，直接`free()`即可。

```c++
template <typename T>
inline
void Vector<T>::push_back(const T &s)
{
    check_alloc();  // reallocate if necessary
    alloc.construct(first_free++, s);
}

template <typename T>
inline 
void Vector<T>::push_back(T &&s)
{
    check_alloc();
    alloc.construct(first_free++, std::move(s));
}

// 成员模板函数
template <typename T>
template <typename... Args>
inline 
void Vector<T>::emplace_back(Args&& ...args)
{
    check_alloc();
    // perfect forwarding
    alloc.construct(first_free++, std::forward<Args>(args)...);
}
```

需要用到`reallocate()`的地方，是往`Vector`里面放入元素，空间不够，就需要重新分配，分配好空间后，直接在空闲位置，原地`contruct()`对象即可。我们知道内存分配和对象构造是独立的两个过程。

至于`emplace_back()`，那就涉及到C++11中的`variadic template`和`perfect forwarding`了。其实就是元素构造的方式不同，`push_back`是利用已有的元素，拷贝构造或者移动构造，`emplace_back`则是直接构造元素。

##### 2. 测试结果

测试结果如下：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190611133547.png)

相关代码都在这里[Github](https://github.com/plantree/Practice)

#### Thinking：

实现一个类，首先要考虑的，是要用它实现什么功能，应用场景是什么样子。如果是仿照库函数，实现自己的版本，自然就要考虑接口的兼容性。第一步，设计一个清晰地接口；第二步，实现一个简单的模型。至于后面的，效率、线程安全等问题，之后考虑，首先要能正确使用，而且代码足够清楚简洁，容易调试。之前看《C++ Primer》，觉得C++11有很多华而不实的语法，很复杂，平常写的时候基本用不到，说到底，是见得少，写的少，语法特性的存在是有它的道理的，比如可变模板参数、完美转发，应用领域有限，但是合适的地方，很好用。

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190611133948.png)

#### Reference：

- 《C++ Primer》

- https://www.zhihu.com/question/36538542/answer/67929747

  