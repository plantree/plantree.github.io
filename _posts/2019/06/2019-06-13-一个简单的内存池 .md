---
layout: post
title: 一个简单的内存池
categories: [C++]
description: 一个简单的内存池
keywords: C++, practice
---

内存池也是池化技术的一种，照我的理解，其实就是“零存整取”。一般情况下，内存的分配和释放是由操作系统负责，时间久了，操作未免细碎化，而且一些系统调用也不是没有代价，不仅造成内存碎片，而且更关键的是，性能会降低。而池化技术，就是将内存管理的工作，从系统层面，转移到用户层面，我们每次从操作系统中取出一大块数据，然后按需分配，按需释放，这样就将多次系统调用转换为一次。尽量减少代价高的操作，平均分摊到所有操作中，那么平均代价就变得可以接受，典型的**摊还分析**。其实标准库中的`std::vector`的动态增长，就蕴含着这样的思想：尽管只需要一个元素的空间，但是分配器分配的是当前大小两倍的空间，看起来有些浪费。但是仔细想一下，是有道理的，因为空间分配后还涉及到对象移动，如果元素很多，必然很耗时，如果每次只是简单增加一个空间，那么效率就很低下。而且美遇到动态增长，就意味着以后还是有着继续增加的趋势，提前分配好，未雨绸缪。

#### Goal

- 实现一个简单的内存池分配器，并与标准分配器`std::allocator`比较

#### Environment

- OS： ubuntu 18.04 (64 bit)
- Compiler: g++ 7.3.0

#### Step

#####　1. 实现

先设计一个`Stack`结构，用于不同分配器之间的比较。

```c++
template <typename T>
struct StackNode
{
    T _data;
    StackNode *_next;
    StackNode() : _data(), _next(nullptr) {} 
};

// 使用std::allocator作为默认分配器
template <typename T, typename Alloc = std::allocator<T>>
class StackAlloc
{
public:
    using Node = StackNode<T>;
    // 同一个分配器绑定其他类型
    using allocator = typename Alloc::template rebind<Node>::other;

    // ctor
    StackAlloc() : _head(nullptr) {}
    // dtor
    ~StackAlloc()
    {
        clear();
    }

    bool empty() const
    {
        return _head == nullptr;
    }

    void clear();

    // 入栈、出栈
    void push(T element);
    T pop();

    T top() const
    {
        return _head->_data;
    }
private:
    Node *_head;
    allocator _allocator;
};
```

比较简单，注意这里的对象构造，被分成了内存分配和对象构造两部部分，内存分配的操作就是借助`allocator`实现的。

```c++
// 同一个分配器绑定其他类型
using allocator = typename Alloc::template rebind<Node>::other;
```

分配器的类型，需要借助内部的一个类执行额外的类型转换，原型是这样的：

```c++
template <class Type> struct rebind {
  typedef allocator<Type> other;
};
```

因为我们本身分配器的类型是`T`，但是我们需要的其实是`allocator<Node>`，借助这个操作就完成了变换。这是一个模板类，而且`other`是个类型，因此需要`typename`帮助编译器识别，否则会被当成静态变量。

下面开始写内存池，其实就是模仿`std::allocator`写一个分配器。

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190613160507.png)

就是仿照`std::allocator`写，内部有个`rebind`转换器，然后把对象的构造和内存的分配释放分离。重点是内部的几个成员变量，`_Slot`是个`Union`，

```c++
// 对象槽，要么被实例化一个存放对象的槽，
// 要么被实例化一个存放槽对象的指针
union _Slot
{
    T _element;
    _Slot *_next;
};
```

之所以设计为`Union`，是因为同一时刻，一个`_Slot`里面，存储的要么是数据，要么是指针，这种互斥性，很适合`Union`，节省空间。

看四个指针分别是做什么的，

`_currentBlock`指向当前区块，因为在申请内存的时候是一次性获取一大块数据；`_currentSlot`指向当前空着的槽的第一个，每个块会被分割成许许多多的小槽；`_lastSlot`指向当前区块中最后一个槽的位置；`_freeSlots`维护的是一个空闲槽的索引，因为内存的分配和释放并不是对等的，时间久了就会形成内部碎片，这里借助一个链表维护空闲内存，也是处理该问题的一种常见思路。

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190613160838.png)

那几个函数一个个看

```c++
MemoryPool() noexcept
{
    _currentBlock = nullptr;
    _currentSlot = nullptr;
    _lastSlot = nullptr;
    _freeSlots = nullptr;
}

~MemoryPool() noexcept
{
    _Slot *cur = _currentBlock;
    while (cur)
    {
        _Slot *next = cur->_next;
        operator delete(reinterpret_cast<void *>(cur));
        cur = next;
    }
}
```

注意这里的构造函数和析构函数都有`noexcept`关键字，这会帮助编译器生成效率更高的代码。而且如果有异常抛出，程序就被立刻`terminate`，在内存分配的时候如果程序还能跑，是没有意义的。构造函数比较简单，看析构函数，看上去就是一个链表的空间释放，事实上也的确如此，我们的内存池，其实就是一个大的链表，从当前区块开始，借助`operator delete`释放内存，这里使用到了`reinterpret_cast`转型，待会儿会看到，因为我们当初申请内存的时候，是一个`BlockSize`申请，因此释放的时候也要按照原来的样子，但是块里现在有很多槽，因此一个强制转型，整个块就没有了。简单、粗暴、有效。

```c++
// 一次分配一个对象
T *allocate(size_t n = 1, const T *hint = nullptr)
{
    // 存在空闲槽
    if (_freeSlots)
    {
        T *result = reinterpret_cast<T *>(_freeSlots);
        _freeSlots = _freeSlots->_next;
        return result;
    }
    else 
    {
        // 对象槽不够用
        if (_currentSlot >= _lastSlot)
        {
            // 分配一个内存区块
            // operator new 只分配空间，不构造对象
            char *newBlock = reinterpret_cast<char *>(operator new(BlockSize));
            reinterpret_cast<_Slot *>(newBlock)->_next = _currentBlock;
            _currentBlock = reinterpret_cast<_Slot *>(newBlock);

            // 内存对齐
            char *body = newBlock + sizeof(_Slot);
            // unsigned integer that is capable of storing a pointer
            //uintptr_t result = reinterpret_cast<uintptr_t>(body);
            //size_t bodyPadding = (alignof(_Slot) - result) % alignof(_Slot);
            //_currentSlot = reinterpret_cast<_Slot *>(body + bodyPadding);
            _currentSlot = reinterpret_cast<_Slot *>(body);
            _lastSlot = reinterpret_cast<_Slot *>(newBlock + BlockSize - sizeof(_Slot));
        }
        return reinterpret_cast<T *>(_currentSlot++);
    }
}

// 销毁指针p指向的内存区块
// 对象析构之后回收内存
void deallocate(T *p, size_t n = 1)
{
    if (p)
    {
        // 将该空间数据转变为_next指针
        reinterpret_cast<_Slot *>(p)->_next = _freeSlots;
        _freeSlots = reinterpret_cast<_Slot *>(p);
    }
}
```

应该说，核心的程序，就是内存的`allocate`和`deallocate`了。

`allocate`的时候，如果存在空闲槽，那么就直接把这个槽拿过来使用即可，`_freeSlots`自然指向下一个，而如果没有空闲槽，就去现在的区块上找空间，如果没有找到，就分配一个大块，区块之间依靠指针相连。空间有了，就可以找位置了，区块的第一个部分，留给了`_currentblock`，额外增加了内存对齐，是因为`_currentBlock`只是个指针，而且永远是，因此需要补齐，但是源代码的内存对齐没有看懂，修改一下也能跑通。

而`deallocate`，只是将当前的对象所在槽，放入`_freeSlots`中，不需要删除，以后自然会被覆盖，很巧妙。

最后就只有对象构造和对象析构了，

```c++
// 调用构造函数，使用std::forward转发变参模板
template <typename U, typename... Args>
    void construct(U *p, Args&&... args)
{
    // https://en.cppreference.com/w/cpp/language/parameter_pack
    // placement new 指定位置构造对象
    new(p) U(std::forward<Args>(args)...);

}

// 调用对象的析构函数
template <typename U>
void destroy(U *p)
{
    p->~U();
}
```

对象构造使用到了`placement new`这种特殊的对象构造方式，说来不复杂，就是在给定内存位置，原地构造对象，自然要传入一些参数，这里就使用到了`perfect forwarding`，参数完美转发。对象析构就是调用自己的析构函数。

##### 2. 测试结果

测试结果如下：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190613164646.png)

可以看出来我们的内存池的确比标准库提供的`std::allocator`按需所需内存要好得多，但是依然比不上`std::vector`。

相关代码都在这里[Github](https://github.com/plantree/Practice)

#### Thinking：

内存池，听名字感觉`geek`，原理说不上多复杂，但是要自自己设计，还是挺难的，虽然能看懂，但是有些用法，比如说`union`，比如说`placement new`，再比如说`reinterpret_cast`，用得好，都不是一件那么容易的事。因此，说到底，还是要多写，多练，多看。

#### Reference：

- https://segmentfault.com/a/1190000013913461

- https://github.com/cacay/MemoryPool

- https://www.shiyanlou.com/courses/566/labs/1929/document/#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E6%B1%A0%E7%AE%80%E4%BB%8B

  