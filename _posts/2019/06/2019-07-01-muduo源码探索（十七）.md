---
layout: post
title: muduo源码探索 (十六)
categories: [muduo]
description: muduo源码探索-Timer
keywords: muduo, network, 网络
---

下面的部分，就要开始涉及到网络库最核心的部分，也就是`EventLoop`类开始参与进来，这是所有网络事件的中枢控制枢纽，几乎所有的其他的类都要有这个类的参与，交互，而且个各类之间的耦合度开始增加，已经不像之前的那些类，可以独立的抽取出来。

不过还是从简单的类入手，尽管会涉及到其他的类，，但是暂时先不去管，后面都会补充。

定时器事件，就是指定一个时间点触发事件，`EventLoop`类的内部也包含一个`TimerQueue`定时器队列，时间到了就会触发事件。传统的等待，使用的是`select(2)`实现超时触发，现在Linux有了`timerfd`，将定时器视为一个普通的文件描述符，这样就很容易纳入到`poll`的管理框架中。

当然，`TimerQueue`是个定时器的集合，基本组成还是普通的`Timer`。

#### Timer

##### 1. 任务

- 封装定时器类

##### 2. 实现

一个定时器，最重要的就是关于时间的描述，直接套用`Timestamp`，有的定时器还有重复的功能，以及每个定时器都有一个标识，不仅如此，定时器事件到来的时候要执行什么操作，就需要一个回调函数。

```c++
// Internal class for timer event
class Timer : noncopyable
{
public:
    Timer(TimerCallback cb, Timestamp when, double interval)
        : callback_(std::move(cb)),
        expriation_(when),  
        interval_(interval),
        repeat_(interval_ > 0.0),
        sequence_(s_numCreated_.incrementAndGet())
    {
    }

    void run() const 
    {
        callback_();
    }

    // 失效时间
    Timestamp expriation() const 
    {
        return expriation_;
    }

    bool repeat() const 
    {
        return repeat_;
    }

    int64_t sequence() const 
    {
        return sequence_;
    }

    // 重启
    void restart(Timestamp now);

    static int64_t numCreated()
    {
        return s_numCreated_.get();
    }
    
private:
    const TimerCallback callback_;  // 定时器回调函数
    Timestamp expriation_;          // 下一次的超时时刻
    const double interval_;         // 超时时间间隔，一次性的话为0
    const bool repeat_;             // 是否重复
    const int64_t sequence_;        // 定时器序号
    
    // 全局
    static AtomicInt64 s_numCreated_;   // 定时器计数
};
```

看上去很简单，有超时时刻，有重复间隔，有回调函数，有一个序列号，并不复杂，对于`restart()`而言，就是计算下一个超时时刻，当然，如果是一个重复定时器的话。

```c++
// 初始为0
AtomicInt64 Timer::s_numCreated_;

void Timer::restart(Timestamp now)
{
    if (repeat_)
    {
        // 重新计算下一个超时时刻
        expriation_ = addTime(now, interval_);
    }
    else 
    {
        // 否则设置为无效
        expriation_ = Timestamp::invalid();
    }
}
```

#### TimerId

##### 1. 任务

- 轻度封装`Timer`

##### 2. 实现

```c++
// An opaque identifier, for canceling Timer
class TimerId : public copyable
{
    friend class TimerQueue;
public:
    TimerId()
        : timer_(nullptr),
        sequence_(0)
    {
    }

    TimerId(Timer *timer, int64_t seq)
        : timer_(timer),
        sequence_(seq)
    {
    }

    // default copy-ctor, dtor and assignment are okay
    // FIXME
    // 底层共享一份资源，内存泄露???
private:
    Timer *timer_;      // 定时器
    int64_t sequence_;  // 序列
};
```

对于这个类的封装，不是特别理解，只不过内部有个`Timer`指针，但是这个指针的生存期也不复杂管理，另外就多了个`sequence_`序号，看起来和`Timer`内部的`sequence_`很像。

#### TimerQueue

##### 1. 任务

- 实现一个维护定时器列表的队列

##### 2. 实现

核心其实都是为了实现一个`TimerQueue`，毋庸置疑，这个队列里是`Timer`的集合，这个类比较复杂。首先，内部用`set`维护这个队列，之所以不选择`vector`或者`list`这类容器的原因，主要是由于`set`内部的红黑树，自动的维护一个顺序，什么顺序，定时器到期的顺序。我们于是明白，定时器队列的最大特点，就在于它内部元素的有序性。额外的操作，就是增加定时器，删除定时器，获取超时的定时器。一个很有意思的地方在于，`TimerQueue`本身和`EventLoop`是`has a`的关系，但是`TimerQueue`的内部有个`EventLoop`指针，目的不言而喻，就是当定时器到期的时候，需要调用`EventLoop`的某些操作。处理定时器的触发事件，采用的是`timerfd`，把一个定时器当做一个文件描述符，纳入到`Poller`监听体系中，当然，每个文件描述符又对应了一个`Channel`，因此`TimerQueue`的内部构成就比较清楚。

```c++
// A best efforts timer queue.
// No guarantee that the callback will be on time
class TimerQueue : noncopyable
{
public:
    explicit TimerQueue(EventLoop *loop);
    ~TimerQueue();

    // schedules the callback to be run at given time,
    // repeats if interval_ > 0.0
    //
    // Must be thread safe. Usually be called from other threads
    // 对于封装了Timer的TimerId操作
    TimerId addTimer(TimerCallback cb,
                    Timestamp when,
                    double interval);
    void cancel(TimerId timerId);

private:
    // (Timestamp, *Timer)
    typedef std::pair<Timestamp, Timer *> Entry;
    // 按时间戳先后顺序排序（红黑树）
    typedef std::set<Entry> TimerList;
    // (Timer *, Sequence)，有效定时器
    typedef std::pair<Timer *, int64_t> ActiveTimer;
    typedef std::set<ActiveTimer> ActiveTimerSet;

    // 该函数只能在所属IO线程中(EventLoop)调用，因此不必加锁，避免了锁竞争
    void addTimerInLoop(Timer *timer);
    void cancelInLoop(TimerId timerId);

    // called when timerfd alarms
    void handleRead();
    // move out all expired timers
    std::vector<Entry> getExpired(Timestamp now);
    void reset(const std::vector<Entry> &expired, Timestamp now);

    // 辅助插入定时器函数
    bool insert(Timer *timer);

    // members
    EventLoop *loop_;
    const int timerfd_;
    Channel timerfdChannel_;    // 绑定到定时器描述符
    // Timer list sorted by expiration
    TimerList timers_;

    // for cancel()
    ActiveTimerSet activeTimers_;
    bool callingExpiredTimers_;     // atomic
    ActiveTimerSet cancelingTimers_;
};
```

先来看几个辅助函数吧，被放在`detail`命名空间里。

```c++
// 创建定时器描述符
// timerfd，纳入poller体系
int createTimerfd()
{
    // CLOCK_MONOTONIC 任何进程都无法更改的单调递增的时钟
    int timerfd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);
    if (timerfd < 0)
    {
        LOG_SYSFATAL << "Failed in timerfd_create";
    }
    return timerfd;
}

// 计算超时时刻与当前时间的时间差
struct timespec howMuchTimeFromNow(Timestamp when)
{
    int64_t microseconds = when.microSecondsSinceEpoch() - Timestamp::now().microSecondsSinceEpoch();
    // FIXME
    if (microseconds < 100)
    {
        microseconds = 100;
    }
    struct timespec ts;
    ts.tv_sec = static_cast<time_t>(microseconds / Timestamp::kMicroSecondsPerSecond);
    ts.tv_nsec = static_cast<long>(microseconds % Timestamp::kMicroSecondsPerSecond) * 1000;
    return ts;
}

// 清除定时器，避免一直触发
// 有读事件说明定时器到时
void readTimerfd(int timerfd, Timestamp now)
{
    uint64_t howmany;
    // 有读事件，就拿出来
    ssize_t n = ::read(timerfd, &howmany, sizeof(howmany));
    LOG_TRACE << "TimerQueue::handleRead() " << howmany << " at " << now.toString();
    if (n != sizeof(howmany))
    {
        LOG_ERROR << "TimerQueue::handleRead() reads " << n << " bytes instead of 8";
    }
}

// 重置定时器的超时时间
void resetTimerfd(int timerfd, Timestamp expiration)
{
    // wake up loop by timerfd_settime()
    struct itimerspec newValue;
    struct itimerspec oldValue;
    memZero(&newValue, sizeof newValue);
    memZero(&oldValue, sizeof oldValue);

    // 一个相对时间，it_interval=0说明只激发一次
    newValue.it_value = howMuchTimeFromNow(expiration);
    int ret = ::timerfd_settime(timerfd, 0, &newValue, &oldValue);
    if (ret)
    {
        LOG_SYSERR << "timerfd_settime()";
    }
}
```

一个就是创建`timerfd`定时器文件描述符，`CLOCK_MONOTONIC`保证了一个永远递增的时钟参考，这与我们的需要是吻合的。该文件描述也被设置为非阻塞和执行时关闭，一贯的操作。

检查时间差，就是将时间戳与当前时间间隔，转换为`timerspec`数据结构。

读定时器事件，是当定时器触发的时候，一定要将该事件处理，否则事件就会一直触发，这个辅助函数实现了`handleRead`的实际功能。

重置定时器的超时时间，系统调用`timerfd_settime`，因为`TimerQueue`中的`Timer`很多，`timerfd`触发当然是根据最近的时间戳，而且设置的时间是距离当前的时间差，是个相对时间。

```c++
TimerQueue::TimerQueue(EventLoop *loop)
    : loop_(loop),
    timerfd_(createTimerfd()),
    timerfdChannel_(loop, timerfd_),
    timers_(),
    callingExpiredTimers_(false)
{
    // 处理timerfd_读事件，也就是有时间到期
    timerfdChannel_.setReadCallback(std::bind(&TimerQueue::handleRead, this));
    // we are always reading the timerfd, we disarm it with timerfd_settime
    timerfdChannel_.enableReading();
}

TimerQueue::~TimerQueue()
{
    // FIXME
    // 先disbaleAll，再移除Poller关注
    timerfdChannel_.disableAll();
    timerfdChannel_.remove();
    ::close(timerfd_);

    // do not remove channel, since we're in EventLoop::dtor()
    // 删除TimerQueue中的所有定时器
    for (const Entry &timer : timers_)
    {
        // delete timer
        delete timer.second;
    }
}
```

构造函数不复杂，就是创建一个定时器文件描述符，然后构造一个管理的`Channel`，定时器队列此时为空。设置`Channel`的读回调函数，并且更新到`Poller`的监听列表。

析构函数，首先要将`Channel`的事件监听取消，然后从`Poller`中移除，关闭定时器文件描述符。对于队列中剩余的`Timer`，一个个清除。

```c++
TimerId TimerQueue::addTimer(TimerCallback cb,
                            Timestamp when,
                            double interval)
{
    Timer *timer = new Timer(std::move(cb), when, interval);
    // 必须在IO线程执行
    loop_->runInLoop(std::bind(&TimerQueue::addTimerInLoop, this, timer));
    return TimerId(timer, timer->sequence());
}

void TimerQueue::cancel(TimerId timerId)
{
    // the same
    loop_->runInLoop(std::bind(&TimerQueue::cancelInLoop, this, timerId));
}

void TimerQueue::addTimerInLoop(Timer *timer)
{
    loop_->assertInLoopThread();
    // 插入一个定时器(到红黑树)，有可能会使得最早到期的定时器发生改变
    bool earliestChanged = insert(timer);

    if (earliestChanged)
    {
        // 重置定时器的超时时刻
        resetTimerfd(timerfd_, timer->expriation());
    }
}

void TimerQueue::cancelInLoop(TimerId timerId)
{
    loop_->assertInLoopThread();
    assert(timers_.size() == activeTimers_.size());
    ActiveTimer timer(timerId.timer_, timerId.sequence_);
    
    // 查找该定时器
    ActiveTimerSet::iterator it = activeTimers_.find(timer);
    // 找到并删除
    if (it != activeTimers_.end())
    {
        // 删除两个地方，timers_和activeTimers_
        size_t n = timers_.erase(Entry(it->first->expriation(), it->first));
        assert(n == 1); (void)n;
        // delete *timer
        delete it->first;   // FIXME: 如果用了unique_ptr就不用手动删除了
        activeTimers_.erase(it);
    }
    else if (callingExpiredTimers_)
    {
        // 已经过期，并且正在调用回调函数的定时器
        cancelingTimers_.insert(timer);
    }
    assert(timers_.size() == activeTimers_.size());
}
```

增加新的定时器和取消定时器，其实都只是表面现象，内部都是要在`IO`线程中进行，也就是`EventLoop`所在线程，因此调用的是`EventLoop`的`runInLoop()`函数，内部是个回调函数。

具体的核心功能，在后面的两个函数中，增加定时器，要判断增加的定时器会不会是第一个触发的，如果是的话，就要重置`timerfd`。取消定时器的话，首先就要找到该定时器的位置，然后删除，如果没有找到，考虑到如果这个时候定时器已经处于调用的过程中，就放到一个取消队列中，后面一次性清除。

```c++
// 处理读事件，回调给Channel
void TimerQueue::handleRead()
{
    loop_->assertInLoopThread();
    Timestamp now(Timestamp::now());
    readTimerfd(timerfd_, now);     // 清除该事件，避免一直触发

    // 获取超时定时器列表
    std::vector<Entry> expired = getExpired(now);

    callingExpiredTimers_ = true;
    // 保证取消队列为空
    cancelingTimers_.clear();
    // safe to callback outside critical section
    for (const Entry &it : expired)
    {
        // 定时器运行回调
        it.second->run();
    }

    callingExpiredTimers_ = false;

    // 如果不是一次性定时器，则需要重启
    reset(expired, now);
}

// RVO返回值优化
std::vector<TimerQueue::Entry> TimerQueue::getExpired(Timestamp now)
{
    assert(timers_.size() == activeTimers_.size());
    std::vector<Entry> expired;
    // FIXME，参考点(极大值)
    Entry sentry(now, reinterpret_cast<Timer *>(UINTPTR_MAX));

    // lower_bound的含义是返回第一个>=sentry的元素的iterator
    // 即*end >= sentry，从而end->first > now
    TimerList::iterator end = timers_.lower_bound(sentry);
    assert(end == timers_.end() || now < end->first);
    // 到期的定时器插入(不包含end)
    std::copy(timers_.begin(), end, std::back_inserter(expired));
    
    // 从timers_中移除
    timers_.erase(timers_.begin(), end);
    // 从activeTimers_中移除
    for (const Entry &it : expired)
    {
        ActiveTimer timer(it.second, it.second->sequence());
        size_t n = activeTimers_.erase(timer);
        assert(n == 1); (void)n;
    }

    assert(timers_.size() == activeTimers_.size());
    return expired;
}
```

对于读事件的回调函数，首先要做的就是清除该事件，直接读出来即可。接着就要获取超时定时器列表，对于每个定时器执行回调。接着就要重置定时器，两个方面要考虑，对于重复的定时器，计算出下一个超时时刻，放入`TimerQueue`中，对于`timerfd`而言，计算下一个超时时刻。

获取失效的定时器列表，返回的是一个`vector`，但是因为`RVO`的原因，这里并不必担心性能。看功能把，因为定时器在一个有序的数据结构中，因此就查找大于该定时器的某个位置，插入到定时器列表，从原有数据结构中清除即可。

```c++
void TimerQueue::reset(const std::vector<Entry> &expired, Timestamp now)
{
    Timestamp nextExpried;

    for (const Entry &it : expired)
    {
        ActiveTimer timer(it.second, it.second->sequence());
        // 重启重复定时器,如果定时器不在取消列表
        if (it.second->repeat() &&
            cancelingTimers_.find(timer) == cancelingTimers_.end())
        {
            it.second->restart(now);
            // 重新插入队列
            insert(it.second);
        }
        else 
        {
            // 一次性定时器或者已被取消，删除
            delete it.second;
        }
    }

    if (!timers_.empty())
    {
        // 获取最早到期的定时器超时时间
        nextExpried = timers_.begin()->second->expriation();
    }

    if (nextExpried.valid())
    {
        // 重置定时器的超时时刻
        resetTimerfd(timerfd_, nextExpried);
    }
}

bool TimerQueue::insert(Timer *timer)
{
    loop_->assertInLoopThread();
    assert(timers_.size() == activeTimers_.size());
    
    // 最早到期时间是否改变
    bool earliestChanged = false;

    Timestamp when = timer->expriation();
    TimerList::iterator it = timers_.begin();
    // 如果timers_为空，或者when小于timers_中的时间
    if (it == timers_.end() || when < it->first)
    {
        earliestChanged = true;
    }

    // 插入到timers_中
    std::pair<TimerList::iterator, bool> result1
        = timers_.insert(Entry(when, timer));
    assert(result1.second); (void)result1;

    // 插入到activeTimers_中
    std::pair<ActiveTimerSet::iterator, bool> result2
        = activeTimers_.insert(ActiveTimer(timer, timer->sequence()));
    assert(result2.second); (void)result2;

    assert(timers_.size() == activeTimers_.size());
    return earliestChanged;
}
```

重置定时器的操作和插入定时器的操作逻辑都很清楚，按下不表。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

Linux的确提供了一些很有用，但是有很偏门的技术，`timerfd`就算是吧，当然这样就不满足跨平台的要求，这是和我们的出发点有关系的，如果我们本身就不考虑跨平台，很多事情就不必再去关注。一定要集中于自己的目的，从原始出发点出来，做出一些权衡，没有十全十美的事物，代码清晰，运行高效的背后，一定是有着一些代价的。当然在学习的时候还是要抱着开放的态度，多种技术都了解，尤其需要明白这种选择的道理，比如`timerfd`，就是为了被纳入`Poller`统一管理体系中。

#### 参考：

- man timerfd_create(2)
- 《Linux多线程服务端编程》
- 《Linux/Unix系统编程手册》
