---
layout: post
title: muduo源码探索 (二十一)
categories: [muduo]
description: muduo源码探索-EventLoopThread&Pool
keywords: muduo, network, 网络
---

这次的内容，涉及到两个类，`EventLoopThread`和`EventLoopThreadPool`类，看名字也知道和`EventLoop`联系密切。上次实现的`EventLoop`类，实现的是单线程`Reactor`，实际上，IO线程未必一定是主线程，主线程可以额外起一个线程作为`EventLoop`使用，不仅如此，如何将充分利用多核心的优势，将单线程`Reactor`推广到多线程中，就需要之前接触到的，池的概念。这里的两个类，就是为了扩展而用。

#### EventLoopThread

##### 1. 任务

- 主线程中另起一个`EventLoop`

##### 2. 实现

```c++
class EventLoopThread : noncopyable
{
public:
    typedef std::function<void(EventLoop *)> ThreadInitCallback;
    
    // 空函数调用
    EventLoopThread(const ThreadInitCallback &cb = ThreadInitCallback(),
                    const string &name = string());   
    ~EventLoopThread();

    EventLoop *startLoop();     // 启动线程，成为IO线程

private:
    void threadFunc();  // 线程函数

    EventLoop *loop_;   // 指向一个EventLoop对象
    bool exiting_;
    Thread thread_;
    MutexLock mutex_;
    Condition cond_;
    ThreadInitCallback callback_;   // 回调函数在loop之前被调用
};
```

要说`EventLoopThread`类，看上去其实并不复杂，内部有一个线程类，一个`EventLoop`指针，创建`EventLoopThread`的线程是主线程，内部的`EventLoop`指针是另一个线程创建，返回出来的。`ThreadInitCallback`回调函数是在创建`EventLoop`的时候执行一些初始化的工作，看到这里还有互斥量和条件变量，因为这里有两个并行的线程，而且`EventLoop`指针是共享的，故而需要一些同步的机制。

```c++
EventLoopThread::EventLoopThread(const ThreadInitCallback &cb,
                                const string &name)
    : loop_(nullptr),
    exiting_(false),
    thread_(std::bind(&EventLoopThread::threadFunc, this), name),
    mutex_(),
    cond_(mutex_),
    callback_(cb)
{
}

EventLoopThread::~EventLoopThread()
{
    exiting_ = true;
    if (loop_) // not 100% race-free, eg. threadFunc could be running callback_
    {
        loop_->quit();  // 退出IO线程
        thread_.join(); // 等待销毁
    }
}
```

构造函数比较简单，创建线程并绑定回调函数。看析构函数，首先要判断是否创建了`EventLoop`，是的话就使用`quit()`退出事件循环，同时等待线程终止。

```c++
EventLoopThread::EventLoopThread(const ThreadInitCallback &cb,
                                const string &name)
    : loop_(nullptr),
    exiting_(false),
    thread_(std::bind(&EventLoopThread::threadFunc, this), name),
    mutex_(),
    cond_(mutex_),
    callback_(cb)
{
}

EventLoopThread::~EventLoopThread()
{
    exiting_ = true;
    if (loop_) // not 100% race-free, eg. threadFunc could be running callback_
    {
        loop_->quit();  // 退出IO线程
        thread_.join(); // 等待销毁
    }
}
```

启动事件循环，返回`EventLoop`指针，实际的工作是交给另一个线程去做的。内部将线程启动，因为不知道哪个线程会先被调度，因此需要等待条件`loop_ != nullptr`为真。而线程的回调函数就是要创建一个`EventLoop`，如果有回调函数，先执行初始化回调，注意这里的`EventLoop`其实是一个栈上的指针，而`loop()`是个无尽的循环，因此当它退出的时候。线程的回调函数就返回，栈上对象自动析构，`EventLoop`指针就自然的失去意义，因此也不必考虑资源释放的问题。基本上，主线程的生命周期和`EventLoop`线程一样长。

#### EventLoopThreadPool

##### 1. 任务

- 实现一个`EventLoop`的线程池

##### 2. 实现

`EventLoopThreadPool`对上面的类又进行了一次扩充，不是一个`EventLoop`线程了，而是多个，构成一个线程池。这个在后面会用到，当一个客户端连接到来的时候，就从`EventLoop`池里调度出一个来执行。主`Reactor`和多个从`Reactor`逻辑分离。

```c++
class EventLoopThreadPool : noncopyable
{
public:
    typedef std::function<void(EventLoop *)> ThreadInitCallback;

    EventLoopThreadPool(EventLoop *baseLoop, const string &nameArg);
    ~EventLoopThreadPool();
    
    void setThreadNum(int numThreads) 
    {
        numThreads_ = numThreads;
    }
    void start(const ThreadInitCallback &cb = ThreadInitCallback());
   
    // valid after calling start()
    // round-robin
    EventLoop *getNextLoop();

    // with the same hash code, it will always return the same EventLoop
    EventLoop * getLoopForHash(size_t hashCode);

    std::vector<EventLoop *> getAllLoops();

    bool started() const 
    {
        return started_;
    }

    slack::string name() const 
    {
        return name_;
    }

private:
    // 与Acceptor中的EventLoop一致
    EventLoop *baseLoop_;
    slack::string name_;
    bool started_;
    int numThreads_;
    int next_;  // 新连接到来，选择的EventLoop对象下标

    std::vector<std::unique_ptr<EventLoopThread>> threads_; // IO线程池
    std::vector<EventLoop *> loops_;
};
```

对于`EventLoopThreadPool`而言，要有一个主`EventLoop`，一般就在主线程里，其他的都在线程池，实际上是用`vector`存储`EventLoopThread`的`unique_ptr`，而`EventLoop`池则直接以指针的形式，存储在`vector`中。

事件的派发，有两种形式，一种是`round-robin`，其实就是顺序派发，一种是根据`hash`，这样可以保证同样的哈希值每次都会分配到同一个线程，充分利用局部性。

```c++
// ctor
EventLoopThreadPool::EventLoopThreadPool(EventLoop *baseLoop, const slack::string &nameArg)
    : baseLoop_(baseLoop),
    name_(nameArg),
    started_(false),
    numThreads_(0),
    next_(0)
{
}

EventLoopThreadPool::~EventLoopThreadPool()
{
    // don't delete loop, it's stack variable
    // EventLoop指向栈对象，会自动析构
}
```

构造函数和析构函数都是平凡的，因为`EventLoop`都是在各自的线程栈上，不用去额外的处理，事件循环结束就会主动析构。

```c++
void EventLoopThreadPool::start(const ThreadInitCallback &cb)
{
    assert(!started_);
    baseLoop_->assertInLoopThread();

    started_ = true;

    // 建立EventLoop线程池
    for (int i = 0; i < numThreads_; ++i)
    {
        char buf[name_.size() + 32];
        snprintf(buf, sizeof buf, "%s%d", name_.c_str(), i);
        EventLoopThread *t = new EventLoopThread(cb, buf);
        threads_.push_back(std::unique_ptr<EventLoopThread>(t));
        loops_.push_back(t->startLoop());   // 启动EventLoopThread线程，进入事件循环前会调用cb
    }

    if (numThreads_ == 0 && cb)
    {
        // 只有一个EventLoop，进入事件循环前调用cb
        cb(baseLoop_);
    }
}
```

`start()`函数是核心，就是创建线程池，直接复用之前的`EventLoop`类。

```c++
EventLoop *EventLoopThreadPool::getNextLoop()
{
    baseLoop_->assertInLoopThread();
    assert(started_);
    EventLoop *loop = baseLoop_;

    // 如果loops_为空，loop指向baseLoop
    // 否则按照round-robin(轮询)
    if (!loops_.empty())
    {
        // round-robin
        loop = loops_[next_++];
        if (implicit_cast<size_t>(next_) >= loops_.size())
        {
            next_ = 0;
        }
    }
    return loop;
}

EventLoop *EventLoopThreadPool::getLoopForHash(size_t hashCode)
{
    baseLoop_->assertInLoopThread();
    EventLoop *loop = baseLoop_;

    if (!loops_.empty())
    {
        loop = loops_[hashCode % loops_.size()];
    }
    return loop;
}

std::vector<EventLoop *> EventLoopThreadPool::getAllLoops()
{
    baseLoop_->assertInLoopThread();
    assert(started_);
    if (loops_.empty())
    {
        return std::vector<EventLoop *>(1, baseLoop_);
    }
    else 
    {
        return loops_;
    }
}
```

事件派发的两种方式都很容易理解，返回所有的`EventLoop`也是相当直接，按下不表。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

真正的多线程`Reactor`模型从此建立，一个主`Rector`，多个从`Reator`，逻辑分离，事件`dispatcher`后就各自处理，这个模型，陈硕老师的《Linux多线程服务端编程》说的很清楚。接下来，就要开始处理网络连接的部分，之前的这些，都还只是脚手架，并没有太多涉及网络编程的地方，网络编程是很复杂的，有很多意外情形要处理。

#### 参考：

- 《Linux多线程服务端编程》
- 《Linux/Unix系统编程手册》
