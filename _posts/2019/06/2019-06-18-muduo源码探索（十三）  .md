---
layout: post
title: muduo源码探索 (十三)
categories: [muduo]
description: muduo源码探索-LogFile/AsyncLogging
keywords: muduo, network, 网络
---

上次实现了两个底层的类，`LogStream`和`Logging`，就是将输入，无论什么类型，都转换为字符串，并增加日期、日志级别等信息，这一次，要将它们，存储到文件里。毕竟程序运行，一旦崩溃，内存里的信息就全部丢失，因此需要及时的保存到硬盘里，这样才能在程序意外退出的时候，检查日志，从而判断出问题的地方。

#### LogFile

##### 1. 任务

- 将缓冲区的内容，按照固定的格式、时间间隔等条件，输出为文件

##### 2. 实现

如果只是单纯的将缓冲区中的内容输出为文件，还不算是一件很困难的事，直接保存成文件就好了嘛。但是问题是，日志的输出，是没有边界的，因此显然不能输出为一个文件，要进行分割，也就是日志记录，会自动的滚动，这里的滚动设置了两个条件：文件大小，以及时间（每当超过零点，就立马新建一个日志文件）。对于文件写的操作，委托给内部的一个`File`类。

```c++
class LogFile : noncopyable
{
public:
    LogFile(const string &basename, 
            off_t rollsize,
            bool threadSafe = true,
            int flushInterval = 3,
            int checkEveryN = 1024);
    ~LogFile();

    void append(const char *logline, int len);
    void flush();
    bool rollFile();

private:
    void append_unlocked(const char *logline, int len);

    static string getLogFileName(const string &basename, time_t *now);

    const string basename_;     // 日志文件basename
    const size_t rollSize_;     // 日志文件rollSize_
    const int flushInterval_;   // 写入间隔时间
    const int checkEveryN_;

    int count_;

    std::unique_ptr<MutexLock> mutex_;  // 智能指针管理mutex_
    time_t startOfPeriod_;              // 开始记录日志时间
    time_t lastRoll_;                   // 上一次滚动时间
    time_t lastFlush_;                  // 最后一次刷新缓冲区
    class File;
    std::unique_ptr<File> file_;

    const static int kRollPerSeconds_ = 60 * 60 * 24;
};
```

有很多看起来很奇怪的变量，其实都是为了确定日志`rollFile()`的时刻。

```c++
// not thread safe
class LogFile::File : noncopyable
{
public:
    explicit File(const string &filename)
        : fp_(::fopen(filename.data(), "ae")),   // append and O_CLOEXEC
        writtenBytes_(0)
    {
        assert(fp_);
        ::setbuffer(fp_, buffer_, sizeof buffer_);  // 设置缓冲区
    }

    ~File()
    {
        ::fclose(fp_);
    }

    void append(const char *logline, const size_t len)
    {
        size_t n = write(logline, len);
        size_t remain = len - n;
        // 没有写完
        while (remain > 0)
        {
            size_t x = write(logline + n, remain);
            // FIXME
            if (x <= 0) // EOF
            {
                int err = ferror(fp_);
                if (err)
                {
                    fprintf(stderr, "LogFile::File::append() failed %s\n", strerror_tl(err));
                }
                break;
            }
            n += x;
            remain = len - n;
        }
        writtenBytes_ += len;
    }

    void flush()
    {
        ::fflush(fp_);
    }

    size_t writtenBytes() const 
    {
        return writtenBytes_;
    }

private:
    size_t write(const char *logline, size_t len)
    {
        #undef fwrite_unlocked
        // 系统的无锁写，非线程安全，不管有没有锁，都会写，性能高
        // stdio是线程安全
        // https://linux.die.net/man/3/flockfile
        return ::fwrite_unlocked(logline, 1, len, fp_);
    }

    FILE *fp_;
    char buffer_[64 * 1024];    // 内部缓冲区
    size_t writtenBytes_;
};
```

`File`对于文件写的操作本身，并不能保证线程安全，而且真正的写操作，执行的还是`fwrite_unocked()`无锁写。查了资料才知道，原来`stdio`中的`I/O`操作都是加了锁的，这里明确的无锁写，赤裸裸的表明非线程安全，就是占了效率高的便宜。这看起来很奇怪，为什么要故意的采取无锁的写呢？

说到底这只是内部的一个，只供`LogFile`调用的类，如果`LogFile`想要实现线程安全，可以在更高层加一个锁，这样就能取得线程安全的效果，如果自己只是单线程，想要追求更高的效率，无锁的写无疑更好。

```c++
void LogFile::append_unlocked(const char *logline, int len)
{
    file_->append(logline, len);    // 写入文件

    // 达到rollSize_
    if (file_->writtenBytes() > rollSize_)
    {
        rollFile();
    }
    else 
    {
        ++count_;
        // 多久检查一次
        if (count_ >= checkEveryN_)
        {
            count_ = 0;
            time_t now = ::time(nullptr);
            // 每天零点新建日志
            time_t thisPeriod_ = now / kRollPerSeconds_ * kRollPerSeconds_;
            if (thisPeriod_ != startOfPeriod_)
            {
                rollFile();
            }
            // 达到刷新间隔
            else if (now - lastFlush_ > flushInterval_)
            {
                lastFlush_ = now;
                file_->flush();
            }
        }
    }
}

// 文件滚动
bool LogFile::rollFile()
{
    time_t now = 0;
    // 获取文件名和now
    string filename = getLogFileName(basename_, &now);
    // 对齐至kRollPerSeconds_的整数倍，也就是时间调整到零点
    time_t start = now / kRollPerSeconds_ * kRollPerSeconds_;

    if (now > lastRoll_)
    {
        lastRoll_ = now;
        lastFlush_ = now;
        startOfPeriod_ = start;
        file_.reset(new File(filename));
        return true;
    }

    return false;
}
```

比较复杂的，就是日志的滚动，其实就是上面说的那两个条件，一个是大小，一个是日期。额外有个`count_`控制检查的频率，毕竟很频繁的计算啥时候滚动日志，是一件十分耗费CPU时间的事情，偶尔检查一下即可。

#### AsyncLogging

##### 1. 任务

- 实现异步日志写入

##### 2. 实现

多线程程序中，对于日志的并发写，想要保证线程安全，就不可避免要使用全局的互斥量。陈硕老师在书中建议，只使用一个背景线程写日志，这样就避免了锁的征用。多线程服务程序，异步日志是必要的，因为如果IO线程或者业务线程直接往磁盘写数据，不可避免要被阻塞，影响其他服务，不如直接单门拎出一个日志线程，专门负责日志的写入。这样，思路就清楚了，其他线程写入到一个中间缓冲区，日志线程从缓冲区里取出，写入到磁盘。典型的生产者消费者模型，可以选择`BlockingQueue`，`muduo`实际采取的是双缓冲区的策略。

先来看看整体思路，再具体到代码。

写日志到磁盘，分为前端和后端，前端写入到缓冲区，后端将缓冲区中的内容写入到磁盘，并发访问的问题，采取了一个很聪明的技巧：前后端都有两个缓冲区，和一个缓冲队列，在互斥区内，将它们交换。于是生产者获得了一个已经被消费了的空缓冲区，消费者获得了生产者产生的数据，各自使用各自的数据，互不干扰。

双缓冲的意义在于，如果当前缓冲区满，后备缓冲区立马跟上，一般情况，两个缓冲区足矣。

```c++
class AsyncLogging : noncopyable
{
public:
    AsyncLogging(const string &basename,
                off_t rollSize,
                int flushInterval = 3);
    ~AsyncLogging()
    {
        if (running_)
        {
            stop();
        }
    }

    void append(const char *logline, int len);

    void start()
    {
        running_ = true;
        thread_.start();
        // 在线程运行之后返回
        latch_.wait();
    }

    void stop()
    {
        running_ = false;
        // 通知后端写
        cond_.notify();
        thread_.join();
    }

private:
    void threadFunc();
    // 缓冲区
    using Buffer = slack::detail::FixedBuffer<slack::detail::kLargeBuffer>;
    using BufferVector = std::vector<std::unique_ptr<Buffer>>;
    using BufferPtr = BufferVector::value_type;

    const int flushInterval_;
    std::atomic<bool> running_;
    const string basename_;
    const off_t rollSize_;

    slack::Thread thread_;      // 日志线程
    slack::CountDownLatch latch_;
    slack::MutexLock mutex_;
    slack::Condition cond_;
    BufferPtr currentBuffer_;   // 当前缓冲区
    BufferPtr nextBuffer_;      // 后备缓冲区
    BufferVector buffers_;
};
```

内部的成员变量就是互斥量、条件变量和缓冲区，这里的`CountDown`的意义在于，主线程会等待背景线程开始工作之后，才会进行接下来的行为。

具体的过程，分为前端写如缓冲区，以及后端背景线程将数据从缓冲区输出到磁盘。

```c++
// 前端写入缓冲区
void AsyncLogging::append(const char *logline, int len)
{
    slack::MutexLockGuard lock(mutex_);
    // 当前缓冲区有剩余
    if (currentBuffer_->avail() > len)
    {
        currentBuffer_->append(logline, len);
    }
    else 
    {
        // 放入后端缓冲区数组，移动语义
        buffers_.push_back(std::move(currentBuffer_));

        // 双缓冲区转移, 后备缓冲区换上
        if (nextBuffer_)
        {
            currentBuffer_ = std::move(nextBuffer_);
        }
        else 
        {
            // 重置
            currentBuffer_.reset(new Buffer);   // rarely happens
        }
        currentBuffer_->append(logline, len);
        // 通知后端可写
        cond_.notify();
    }
}
```

就是照刚才说的。如果`currentBuffer_`有空位置，直接写入，否则，提交到数组中，如果后备缓冲区可用，直接替换，不然就得重新初始化，不过这种情况很少发生。这个时候通知后端，该写了。这样就将细小的操作批量化，不会每次写入都触发背景线程醒来工作，无疑提高了效率。

```c++
// 后端异步写
void AsyncLogging::threadFunc()
{
    assert(running_ == true);
    latch_.countDown();
    // 非线程安全, 因为只有一个线程写
    LogFile output(basename_, rollSize_, false);
    // 准备两个缓冲区，与前端对应
    BufferPtr newBuffer1(new Buffer);
    BufferPtr newBuffer2(new Buffer);
    newBuffer1->bzero();
    newBuffer2->bzero();
    BufferVector buffersToWrite;
    buffersToWrite.reserve(16);

    while (running_)
    {
        assert(newBuffer1 && newBuffer2->length() == 0);
        assert(newBuffer2 && newBuffer2->length() == 0);
        assert(buffersToWrite.empty());
        // 前后端缓冲区交换
        {
            slack::MutexLockGuard lock(mutex_);
            // 没有要写的，等候flushInterval_
            if (buffers_.empty())   // rarely happens
            {
                cond_.waitForSeconds(flushInterval_);
            }
            // 强制缓冲区移入
            buffers_.push_back(std::move(currentBuffer_));
            // 置为空
            currentBuffer_ = std::move(newBuffer1);
            // 交换缓冲区
            buffersToWrite.swap(buffers_);
            if (!nextBuffer_)
            {
                nextBuffer_ = std::move(newBuffer2);
            }
        }

        assert(!buffersToWrite.empty());

        // 太多直接丢弃
        if (buffersToWrite.size() > 25)
        {
            char buf[256];
            snprintf(buf, sizeof buf, "Dropped log message at %s, %zd larger buffers\n",
                Timestamp::now().toFormattedString().c_str(),
                buffersToWrite.size()-2);
            fputs(buf, stderr);
            // 写入信息
            output.append(buf, static_cast<int>(strlen(buf)));
            // 保留前两个日志
            buffersToWrite.erase(buffersToWrite.begin()+2, buffersToWrite.end());
        }

        // 写入文件
        for (const auto &buffer : buffersToWrite)
        {
            output.append(buffer->data(), buffer->length());
        }

        // 保留两个
        if (buffersToWrite.size() > 2)
        {
            buffersToWrite.resize(2);
        }

        // 被换出到currentBuffer_
        if (!newBuffer1)
        {
            assert(!buffersToWrite.empty());
            newBuffer1 = std::move(buffersToWrite.back());
            buffersToWrite.pop_back();
            newBuffer1->reset();
        }

        // 被换出到nextBuffer_
        if (!newBuffer2)
        {
            assert(!buffersToWrite.empty());
            newBuffer2 = std::move(buffersToWrite.back());
            buffersToWrite.pop_back();
            newBuffer2->reset();
        }

        buffersToWrite.clear();
        output.flush();
    }
    output.flush();
}
```

背景线程的后端写入磁盘，也得提前准备好两个缓冲区和一个空的缓冲数组，在临界区，与前端的数据交换，这里的条件等待，有两种唤醒的可能，一个是超时，一个是被`notify()`。这里的`if`，说明这个条件并不是一定要为真才继续接下来的动作，不然超时触发就失去意义了。

如果缓冲区数组中数据太大，说明生产者生产的速度远大于消费的速度，直接丢弃。是否有些太过武断，不是特别清楚。

将缓冲数组中的元素输出到磁盘里。

后端的两个缓冲区要清空，这里使用到了一些技巧，避免内存的额外分配。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

整个`log`库就到这里，实现了四个类，各司其职。Unix哲学就是，一个程序，做且只做好一件事。在写的过程中，也的确发生了抽象和封装带来的好处，一来代码思路更加清楚，二来代码之间的耦合度很低，在做单元测试的时候就比较容易。异步日志，背景线程，实现的方法的确很有意思，可见自己的见识还是太少，见得少，写的少。

接下来，基础工作搭建完成，就该写具体的网络库了。

#### 参考：

- 《Linux多线程服务端编程》
- 《Linux/Unix系统编程手册》
