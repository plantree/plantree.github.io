---
layout: post
title: muduo源码探索 (五)
categories: [muduo]
description: muduo源码探索-Mutex/Condition/CountDownLatch
keywords: muduo, network, 网络
---

这次的任务，说简单也简单，但是细节要格外注意。而且今天实现的三个类，对于多线程而言是极其重要的，最基础、最核心的同步同工具，分别是`Mutex`、`Condition`以及`CountDownLatch`。都是借助C++的类，对于操作系统提供的C语言接口的简单封装，不算特别复杂，而且代码清楚，不得不说，借助C++的`RAII`手法管理资源的生存期，真的是又清楚又方便。

两点需要说明：

1. 我们都知道，多线程模型，对于变量的共享，是很容易的，当然要付出“数据同步”的代价。`race condition`是不可避免的，线程同步的基础设施也很多，陈硕老师在《Linux多线程服务端编程》里提到的几点建议就是：只使用非递归互斥器和条件变量，不使用更复杂的读写锁和信号量；借助`RAII`手法封装mutex的创建、销毁、加锁和解锁的动作，不手动`lock/unlock`；条件变量必须和mutex一起使用，只有在mutex锁住的时候才能`wait`，而且要用循环等待条件变量
2. C++11提供了语言层面的并发原语，当然自己封装也不是特别碍事，而且对于`Pthread`库多了一些了解。事后可以再尝试学习C++提供的`Thread`支持

#### Mutex

##### 1. 任务

- 封装`mutex`，借助`RAII`手法完成互斥量的初始化、销毁、加锁和解锁的动作
- 分为`MutexLock`（底层锁资源管理）和`MutexLockGuard`（使用）

##### 2. 实现

`MutexLock`类不复杂，内部只有两个成员变量`mutex_`和`holder_`，分别代表互斥量和进程ID。类的构造函数初始化`mutex_`，析构函数销毁`mutex_`。内部的操作完全是`Pthread`对于互斥量的操作。

```c++
// RAII
class MutexLock : noncopyable 
{
public:
    MutexLock() : holder_(0)
    {
        int ret = pthread_mutex_init(&mutex_, nullptr);
        assert(ret == 0); (void)ret;
    }

    // cannot copy-ctor and assignment

    ~MutexLock()
    {
        // 必须在没有线程持有锁的时候才能销毁
        assert(holder_ == 0);
        int ret = pthread_mutex_destroy(&mutex_);
        assert(ret == 0); (void)ret;
    }

    // 判断是否自己持有锁
    bool isLockedByThisThread() const
    {
        return getHolder() == CurrentThread::tid();
    }
    
    // 必须锁住
    void assertLocked()
    {
        assert(isLockedByThisThread());
    }

    // internal usage
    void lock()
    {
        int ret = pthread_mutex_lock(&mutex_);
        assert(ret == 0); (void)ret;
        assignHolder();
    }

    void unlock()
    {
        // 逆序
        unassignHolder();
        int ret = pthread_mutex_unlock(&mutex_);
        assert(ret == 0); (void)ret;
    }

    // 获取内部锁
    pthread_mutex_t *getPthreadMutex()
    {
        return &mutex_;
    }
    pid_t getHolder() const 
    {
        return holder_;
    }
private:
    friend class Condition;

    class UnassignGuard : noncopyable
    {
    public:
        explicit UnassignGuard(MutexLock &owner)
            : owner_(owner)
        {
            // 释放
            owner_.unassignHolder();
        }
        ~UnassignGuard()
        {
            // 重新获取
            owner_.assignHolder();
        }
    private:
        MutexLock &owner_;
    };

    void assignHolder()
    {
        holder_ = CurrentThread::tid();
    }

    void unassignHolder()
    {
        holder_ = 0;
    }

    pthread_mutex_t mutex_;     // 互斥锁
    pid_t holder_;         // 持有锁的线程ID
};
```

`UnassignGuard`类是帮助后面条件变量，管理锁的归属问题，因为条件变量在`wait`的时候会隐式的释放锁，因此就应该对应的修改`holder_`的值。因为也就只有`Condition`会用到，因此实现为内部类，同时增加友元。

而`MutexLockGuard`就更简单了，构造函数的时候锁住互斥量，析构的时候释放，因为`MutexLock`是不可拷贝的，因此内部的`mutex_`必须是引用，而且并不负责管理它的生命期。

```c++
// 避免直接的对锁进行操作，lock/unlock必须对应，遇到异常可能出错
// 借助对象管理资源RAII
class MutexLockGuard : noncopyable
{
public:
    explicit MutexLockGuard(MutexLock &mutex) : mutex_(mutex)
    {
        mutex_.lock();
    }

    ~MutexLockGuard()
    {
        mutex_.unlock();
    }
private:
    MutexLock &mutex_;      // mutex_是不可拷贝的！！！不负责管理生存周期
};
```

#### Condition

##### 1. 任务

在`MutexLock`的基础上封装条件变量。

##### 2. 实现

内部也就只有一个`mutex_`和`cond_`罢了，也还是`Pthread`中条件变量语义的简单封装。具体如何使用后面会提到。

```c++
class Condition : noncopyable
{
public:
    // mutex_引用传递
    explicit Condition(MutexLock &mutex) : mutex_(mutex)
    {
        int ret = pthread_cond_init(&pcond_, nullptr);
        assert(ret == 0); (void)ret;
    }

    ~Condition()
    {
        int ret = pthread_cond_destroy(&pcond_);
        assert(ret == 0); (void) ret;
    }

    // 等待条件变量
    void wait()
    {
		MutexLock::UnassignGuard ug(mutex_);
        pthread_cond_wait(&pcond_, mutex_.getPthreadMutex());
    }

    // returns true if time out, false otherwisw
    bool waitForSeconds(double seconds);

    // 通知
    void notify()
    {
        pthread_cond_signal(&pcond_);
    }

    void notifyAll()
    {
        pthread_cond_broadcast(&pcond_);
    }
private:
    MutexLock &mutex_;
    pthread_cond_t pcond_;
};
```

增加了一个超时的等待，选择`CLOCK_MONOTONIC`，是因为可以确保获取的时间是线性增长，不会有`CLOCK_REALIME`产生的时间回滚的情况，网上有[讨论](https://stackoverflow.com/questions/3523442/difference-between-clock-realtime-and-clock-monotonic)。

```c++
// return true if time out
bool slack::Condition::waitForSeconds(double seconds)
{
    struct timespec abstime;
    // 系统级真实时间
    // FIXME
    //clock_gettime(CLOCK_REALTIME, &abstime);
    clock_gettime(CLOCK_MONOTONIC, &abstime);
    
    const int64_t kNanoSecondsPerSecond = 1000000000;
    int64_t nanoSeconds = static_cast<int64_t>(seconds * kNanoSecondsPerSecond);

    abstime.tv_sec += static_cast<time_t>((abstime.tv_nsec + nanoSeconds) / kNanoSecondsPerSecond);
    abstime.tv_nsec += static_cast<long>((abstime.tv_nsec + nanoSeconds) % kNanoSecondsPerSecond);
    
    return pthread_cond_timedwait(&pcond_, mutex_.getPthreadMutex(), &abstime) == ETIMEDOUT;
}
```

#### CountDownLatch

##### 1. 任务

倒计时是一种常用的同步手段，主要用途是：

1. 主线程发起多个子线程，等待子线程各自完成任务后主线程才继续执行
2. 主线程发起多个子线程，等待主线程完成一些任务后，通知所有子线程开始执行，发出“起跑动作”

##### 2. 实现

内部成员变量只有上面封装的互斥量和条件变量，应该算是这两者的典范使用吧。

```c++
// 条件变量的正确使用
void CountDownLatch::wait()
{
    MutexLockGuard lock(mutex_);
    // 避免假唤醒，用while
    while (count_ > 0)
    {
        condition_.wait();
    }
}

void CountDownLatch::countDown()
{
    MutexLockGuard lock(mutex_);
    --count_;
    // 通知
    if (count_ == 0)
    {
        condition_.notifyAll();
    }
}
```

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

线程同步的手段有很多，其实只要用好其中一两个就好。多线程编程中，要尽可能的保持简单，一来容易调试，二来不容易出错，不要一味的为了炫技，选择复杂的技术，朴素的技术，恰到好处的能解决问题，就好。而且，目前所做的，都是对与工具进行封装，将底层的复杂性进一步包装、隐藏，留给高层的，只是一个清晰一致的接口，这也是为了控制复杂度。

#### 参考：

- http://www.importnew.com/15731.html

- https://stackoverflow.com/questions/3523442/difference-between-clock-realtime-and-clock-monotonic

- https://www.zhihu.com/question/36236334

- 《Linux多线程服务端编程》

  

