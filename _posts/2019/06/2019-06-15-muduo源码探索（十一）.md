---
layout: post
title: muduo源码探索 (十一)
categories: [muduo]
description: muduo源码探索-FileUtil/ProcessInfo
keywords: muduo, network, 网络
---

`base`部分差不多就结束了，本来只是打算写`ProcessInfo`类，是从`/proc`文件里提取进程的运行情况，没想到角落里还隐藏着一个`FileUtil`类，望文生义，封装了一些文件操作方面的类，好在并不复杂，两个一起说。

#### FileUtil

##### 1. 任务

- 封装文件的读取操作

##### 2. 实现

类并不复杂，内部有个缓冲区，给定文件名，拿出一些信息，包括`i-node`节点里的文件属性信息和文件内容

```c++
// read small file < 64KB
class ReadSmallFile : noncopyable
{
public:
    ReadSmallFile(StringArg filename);
    ~ReadSmallFile();

    // return errno
    // 函数模板隐式推导
    template <typename String>
    int readToString(int maxSize,
                    String *content,
                    int64_t *fileSize,
                    int64_t *modifyTime,
                    int64_t *createTime);
    
    // read at maximum kBufferSize into buf_
    // return errno
    int readToBuffer(int *size);

    const char *buffer() const 
    {
        return buf_;
    }

    static constexpr int kBufferSize = 64 * 1024;

private:
    int fd_;                // 文件描述符
    int err_;               // 错误信息
    char buf_[kBufferSize]; // 内部缓冲区
};
```

依然是借助`RAII`特性，构造函数里打开文件，析构函数李关闭文件，文件打开的方式有些特别，

```c++
// 只读模式打开，exec的时候自动关闭文件描述符，多线程必要，避免数据竞争
// fcntl也可以设置，但是不是原子操作
FileUtil::ReadSmallFile::ReadSmallFile(StringArg filename)
    : fd_(::open(filename.c_str(), O_RDONLY | O_CLOEXEC)),
    err_(0)
{
    buf_[0] = '\0';
    if (fd_ < 0)
    {
        err_ = errno;
    }
}
```

之所以选择`O_CLOEXEC`，主要还是为了从多线程安全考虑，如果某个线程打开一个文件描述符，而另一个线程`fork()`一个进程，会同时复制文件描述符，而如果执行`exec()`的操作，文件描述符默认情况下并不会自动关闭，这样文件的引用计数会一直存在，就不会被关闭，`O_CLOEXEC`就是为了解决这个问题。`fcntl()`也可以修改文件属性，但是不是原子操作，在多线程环境下存在`race　condition`的风险。

至于文件的读取，就涉及到`stat()`获取文件属性信息，以及反复的`read()`，直到取得全部的数据。

```c++
// read the file content, return errno if error happens
template <typename String>
int readFile(StringArg fileName,
            int maxSize,
            String *content,
            int64_t *fileSize = nullptr,
            int64_t *modifyTime = nullptr,
            int64_t *createTime = nullptr)
{
    ReadSmallFile file(fileName);
    return file.readToString(maxSize, content, fileSize, modifyTime, createTime);
}
```

通过一个外部的函数，连对象的建立都免了，直接就拿到数据了。

#### ProcessInfo

##### 1. 任务

- 从`/proc`文件里获取进程的运行信息

##### 2. 实现

首先得直到`/proc`文件是什么。`/proc`可以理解为是一个文件系统，只不过是存储在内存中的区域，使用的时候就像操作本地文件一样，比如：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190612211327.png)

很多文件夹，带数字的都是进程的名字。`/proc`文件系统当初开发就是为了提供有关系统中进程的信息，《深入理解计算机系统》书里说：

> Linux提供了一种聪明的机制，叫做/proc文件系统，允许用户模式进程访问内核数据结构的内容，/proc文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文件的层次结构

进程内部还有更多的文件夹

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190612212758.png)

想要获取进程的相关信息，就去对应的文件夹中找即可

```c++
namespace ProcessInfo
{
    pid_t pid();
    string pidString();
    uid_t uid();
    string userName();
    uid_t euid();
    Timestamp startTime();
    int clockTicksPerSecond();
    int pageSize();
    bool isDebugBuild();    // constexpr
    
    string hostName();
    string procName();
    StringPiece procName(const string &stat);

    // read /proc/self/status
    string procStatus();

    // read /proc/self/stat
    string procStat();

    // read /proc/self/task/tid/stat
    string threadStat();

    // readlink /proc/self/exe
    string exePath();

    int openedFiles();
    int maxOpenFiles();

    struct CpuTime
    {
        double userSeconds;
        double systemSeconds;

        CpuTime() : userSeconds(0.0), systemSeconds(0.0) { }

        double total() const 
        {
            return userSeconds + systemSeconds;
        }
    };

    CpuTime cpuTime();

    int numThreads();
    std::vector<pid_t> threads();
    
}   // namespace ProcessInfo
```

在实现的时候用了一些特殊的函数，比如`scandir()`，需要自己写一些回调函数帮助函数找到我们所需要的信息。是一些比较复杂，而且平时很少见到的机制，不过个人感觉，就事论事，需要的时候知道去哪里查就好了。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

`FileUtil`和`ProcessInfo`都比较简单，当然是看源码觉得比较简单，自己写的话还是挺复杂的，一些用法都是第一次遇到。可见Linux里面，小的工具的确很多，用好了就很节省时间，这些用法，不去看优秀的程序库，书本上恐怕是遇不到的。而且Linux提供的很多特性，朴实无话，真的务实，没有虚头巴脑，有，说明就有用。还是要好好研究一番。

`base`的封装就到这里，基本的工具已经搭建好，后面在写`net`库的时候会用到其中的一些。因为`base`库里的程序都经过了单元测试，而且接口也比较清楚，后面在使用的时候，就暂时不再去考虑内部的实现，屏蔽了复杂性，只专注于眼前的任务，而不是每个问题就追根问题，还是要分清楚主次。

#### 参考：

- https://blog.csdn.net/analogous_love/article/details/53096028
- https://blog.csdn.net/sty23122555/article/details/51638697
- https://blog.csdn.net/sty23122555/article/details/51638697
- 《深入理解计算机系统》
