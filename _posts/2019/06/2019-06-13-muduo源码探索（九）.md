---
layout: post
title: muduo源码探索 (九)
categories: [muduo]
description: muduo源码探索-BlockingQueue/BoundedBlockingQueue
keywords: muduo, network, 网络
---

今天要实现的，与其说是两个类，不如说是两个数据结构，`BlockingQueue`和`BoundedBlockingQueue`，实现多线程环境下数据的存取，典型的“生产者/消费者”模型。可以相见内部的实现必然要使用互斥量和条件变量，依旧是借助于封装，在使用的时候，直接从外部`put()`或者`get()`即可，不必考虑内部的线程同步问题。

`muduo`源代码中的`BoundedBlockingQueue`使用到了`Boost`里的环形队列，这里略微修改一下，变得更像之前线程池里的实现，借助的是`std::deque`。

#### BlockingQueue

##### 1. 任务

- 实现多线程环境下阻塞队列

##### 2. 实现

有了之前封装好的底层类，`BlockingQueue`的内部变得异常精简。

```c++
template <typename T>
class BlockingQueue : noncopyable
{
public:
    BlockingQueue()
        : mutex_(),
        notEmpty_(mutex_),
        queue_()
    {
    }

    // 生产者
    void put(const T &x)
    {
        MutexLockGuard lock(mutex_);
        queue_.push_back(x);
        notEmpty_.notify();     // TODO: move outside of lock
    }

    void put(T &&x)
    {
        MutexLockGuard lock(mutex_);
        queue_.push_back(std::move(x));
        notEmpty_.notify();
    }

    // 消费者
    T take()
    {
        MutexLockGuard lock(mutex_);
        // always use a while loop, due to spurious wakeup
        while (queue_.empty())
        {
            notEmpty_.wait();
        }
        assert(!queue_.empty());
        T front(std::move(queue_.front()));
        queue_.pop_front();
        return front;
    }

    size_t size() const
    {
        MutexLockGuard lock(mutex_);
        return queue_.size();
    }
private:
    mutable MutexLock   mutex_;
    Condition           notEmpty_;
    std::deque<T>       queue_;
};

```

这里只有一个互斥量和条件变量，这是一个无界队列，如果队列为空，消费者就要去睡眠，等待条件变量的唤醒。这里条件变量的时候是教科书级的，先锁住互斥量，然后循环判断条件（避免虚假唤醒，其实条件变量最好应该理解为可能性而不是确定性），条件不成立就去睡眠，并释放锁，等待被唤醒。多说一句，条件变量为什么要和互斥量一起使用？这是因为这两者的意义是不一样的，互斥量是防止多个线程同时访问同一共享变量，条件变量是针对某个共享变量的状态变化通知其他线程。条件变量可以理解为两个东西，一个是`pthread_cond_t`类型的那个变量，另外一个就是被监视的那个会变化的条件所在的变量，这里的就是`_queue`，互斥量真正保护，是它。

另外一个，我之前也遇到过，陈硕老师代码里也标注，但是网页打不开，就是条件变量的`notify()`是否应该在互斥区？

《Linux/Unix系统编程手册》p534提到，

> 在某些实现中，先解锁互斥量再通知条件变量可能比反序执行效率要高

但是[StackoverFlow](https://stackoverflow.com/questions/1640389/pthreads-pthread-cond-signal-from-within-critical-section)网站里的建议却是在互斥区里`notify()`，

> The thread waiting on the condition variable should keep the mutex locked, and the other thread should always signal with the mutex locked. This way, you *know* the other thread is waiting on the condition when you send the signal. Otherwise, it's possible the waiting thread won't see the condition being signaled and will block indefinitely waiting on it.

这个其实是依赖于操作系统的调度策略，不过就可读性和正确性而言，推荐放在互斥区里。

#### BoundedBlockingQueue

##### 1. 任务

- 实现多爱线程环境下的有界阻塞队列

##### 2. 实现

这个和刚才的不一样，队列变成有界的，那么就存在满的情况，此刻生产者应该被投入睡眠。和线程池实现的策略一样，使用两个条件变量，一个通知生产者，一个通知消费者，和线程池模型几乎没什么差别，改动很小。只要理解为什么要使用两个条件变量即可。

```c++
template <typename T>
class BoundedBlockingQueue : noncopyable
{
public:
    explicit BoundedBlockingQueue(int maxSize)
        : mutex_(),
        notEmpty_(mutex_),
        notFull_(mutex_),
        capacity_(maxSize)
    {
    }

    void put(const T &x)
    {
        MutexLockGuard lock(mutex_);
        while (queue_.size() == capacity_)
        {
            notFull_.wait();
        }
        assert(queue_.size() < capacity_);
        queue_.push_back(x);
        notEmpty_.notify();     // TODO: move outsize of lock
    }
    
    void put(T &&x)
    {
        MutexLockGuard lock(mutex_);
        while (queue_.size() == capacity_)
        {
            notFull_.wait();
        }
        assert(queue_.size() < capacity_);
        queue_.push_back(std::move(x));
        notEmpty_.notify();    
    }

    T take()
    {
        MutexLockGuard lock(mutex_);
        while (queue_.empty())
        {
            notEmpty_.wait();   
        }
        assert(!queue_.empty());
        T front(std::move(queue_.front()));
        queue_.pop_front();
        notFull_.notify();
        return front;
    }

    bool empty() const
    {
        MutexLockGuard lock(mutex_);
        return queue_.empty();
    }

    bool full() const
    {
        MutexLockGuard lock(mutex_);
        return queue_.size() == capacity_;
    }

    size_t size() const
    {
        MutexLockGuard lock(mutex_);
        return queue_.size();
    }

    size_t capacity() const
    {
        MutexLockGuard lock(mutex_);
        return capacity_;
    }
private:
    mutable MutexLock mutex_;
    Condition notEmpty_;
    Condition notFull_;
    size_t capacity_;
    std::deque<T> queue_;
};
```



代码可见[Github](https://github.com/plantree/Slack)

#### 思考

这两个数据结构，后面其实也没有用到，其实考虑了一下，`BoundedBlockingQueue`完全可以用在线程池类里。常规的数据结构，在多线程环境下都失效了，解决的方案大体有两个：一个是通过互斥量解决，另一个是无锁数据结构。无锁数据结构了解不多，今后有时间，再去仔细研究一番。细节，还是细节！

#### 参考：

- https://stackoverflow.com/questions/1640389/pthreads-pthread-cond-signal-from-within-critical-section
- 《Linux/Unix系统编程手册》
