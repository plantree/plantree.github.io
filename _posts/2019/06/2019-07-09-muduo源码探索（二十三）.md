---
layout: post
title: muduo源码探索 (二十三)
categories: [muduo]
description: muduo源码探索-Acceptor
keywords: muduo, network, 网络
---

上一次说的是`Connector`，用在客户端程序，用于主动建立连接，封装的是`connect()`函数，以及监听在其上的事件。这一次的内容，是`Acceptor`，用于服务端程序，接收请求，封装的是`accept()`的功能。

#### Acceptor

##### 1. 任务

- 实现一个能够接收连接的类，同时建立起新的连接

##### 2. 实现

这个类是作为`TcpServer`的一部分，生存期受后者的管理

```c++
// Acceptor of incoming TCP connection
class Acceptor : noncopyable
{
public:
    // 连接回调，（sockfd， address）
    using NewConnectionCallback = std::function<void(int sockfd, 
                                                    const InetAddress &)>;
    Acceptor(EventLoop *loop, const InetAddress &listenAddr, bool reusePort);
    ~Acceptor();

    void setNewConnectionCallback(const NewConnectionCallback &cb)
    {
        newConnectionCallback_ = cb;
    }

    bool listenning() const 
    {
        return listenning_;
    }
    void listen();

private:
    void handleRead();

    EventLoop *loop_;

    Socket acceptSocket_;   // connetion socket
    Channel acceptChannel_; 
    
    NewConnectionCallback newConnectionCallback_;
    bool listenning_;
    int idleFd_;    // 处理已用文件描述符过多的情况
};
```

头文件不复杂，构造函数只有`EventLoop`指针和监听IP地址，有一个新连接建立时的回调函数。因为是注到你接收连接，自然免不了要处理可读事件，所有的监听事件都是通过`Channel_`实现的，内部有个监听套接字`Socket`类，以及它的`Channel`。对于`idleFd_`而言，后面再说，属于一个小技巧。

```c++
Acceptor::Acceptor(EventLoop *loop, const InetAddress &listenAddr, bool reusePort)
    : loop_(loop),
    acceptSocket_(sockets::createNonBlockingOrDie(listenAddr.family())),
    acceptChannel_(loop, acceptSocket_.fd()),
    listenning_(false),
    idleFd_(::open("/dev/null", O_RDONLY | O_CLOEXEC))
{
    assert(idleFd_ >= 0);
    acceptSocket_.setReuseAddr(true);
    acceptSocket_.setReusePort(reusePort);
    acceptSocket_.bindAddress(listenAddr);
    // 设置读回调
    acceptChannel_.setReadCallback(std::bind(&Acceptor::handleRead, this));
}

Acceptor::~Acceptor()
{
    // 移除Channel
    acceptChannel_.disableAll();
    acceptChannel_.remove();
    ::close(idleFd_);
}

void Acceptor::listen()
{
    loop_->assertInLoopThread();
    listenning_ = true;
    // listen
    acceptSocket_.listen();
    // 读事件注册到底层Poller
    acceptChannel_.enableReading();
}
```

构造函数中还是做了不少的事情的，首先就是创建一个非阻塞套接字，`TcpServer`当然需要，自己都没有套接字，怎么去接受连接，另外在最开始就为`idleFd_`赋了一个很小的值，后面会遇到，属于提前预留一个坑位。然后就要绑定套接字的监听地址，同时设置`channel_`的可读事件回调。

对于析构函数而言，就是将`channel_`从监听列表中移除，同时关闭打开的文件描述符。`Socket`类的析构不用去管，自然会死亡。

对于监听连接到来而言，也一定是在IO线程上，同时让`Poller`监听`Channel`上的可读事件。

```c++
void Acceptor::handleRead()
{
    loop_->assertInLoopThread();
    InetAddress peerAddr;
    // FIXME loop until no more
    int connfd = acceptSocket_.accept(&peerAddr);
    if (connfd >= 0)
    {
        string hostport = peerAddr.toIpPort();
        LOG_TRACE << "Accepts of " << hostport;
        // 存在新连接回调
        if (newConnectionCallback_)
        {
            newConnectionCallback_(connfd, peerAddr);
        }
        else 
        {
            // 否则关闭连接
            sockets::close(connfd);
        }
    }
    else 
    {
        LOG_SYSERR << "in Acceptor::handleRead";
        // 已用的文件描述符号超过系统限制
        // 接收连接然后关闭，不服务
        if (errno == EMFILE)
        {
            ::close(idleFd_);
            idleFd_ = ::accept(acceptSocket_.fd(), nullptr, nullptr);
            ::close(idleFd_);
            idleFd_ = ::open("/dev/null", O_RDONLY | O_CLOEXEC);
        }
    }
}
```

当可读事件到来的时候，要做的事情比较多，首先就是`accept()`连接，此时会生成连接套接字，如果连接套接字合法，那么就可以执行`newConnectionCallback()`，这个回调函数是从`TcpServer`过来的，拿到连接套接字，`TcpServer`在上层就可以建立`TcpConnection`了。如果连接套接字有问题，那么就要看是不是`EMFILE`问题，如果是，则说明连接数建立的太多，这个事件是一定要处理，否则每次都会触发，造成`busy loop`，处理的方法有很多，比如提高进程的最大文件描述符数量，这个不是长久之计，或者就是等待，直到有文件描述符关闭，然后`accept()`，这里采用的是，先关闭`idleFd_`，那么获取一个坑，然后在接收连接，然后立马关闭，`idleFd_`恢复出厂设置。也就是说，当并发连接数到达一定数目后，就停止服务了。

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

`idleFd_`的使用真的是花式操作，不接触这些生产环境的代码，根本想不到实际使用中的问题会从哪个地方出来。有问题，就有解法，抱着实用主义的心态，遇到问题，解决问题，一点点积累，经验这种东西，就是犯了错，撞得头破血流才会明白的。`Acceptor`不复杂，但是接下来的，`TcpConnection`类，就是整个网络库中，最复杂的类了，而且生命期很模糊，也是使用了一些技巧。主要是智能指针。

#### 参考：

- https://www.cnblogs.com/perfy576/p/8617320.html
- 《Linux多线程服务端编程》
- 《Linux/Unix系统编程手册》
