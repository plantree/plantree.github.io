---
layout: post
title: 一个简单的内存泄露检测器
categories: [C++]
description: 一个简单的内存泄露检测器
keywords: C++, practice
---

平时在开发的过程中，尤其总是写C和C++的程序，直接操纵裸指针，自然明白风险，也知道用一些内存泄露检测工具，比如说`Valgrind`。作为使用者而言，工具本身很好用，而且运行的结论清楚，知道怎么修改。至于内在实现的原理，倒没有去了解过。恰好在实验楼看到一个[课程](https://www.shiyanlou.com/courses/657/labs/2130/document/)，觉得很有意思，就看了一下。当然代码本身很简单了，毕竟只是练手，但是有些想法还是挺值得玩味的，比如：怎么检测内存的泄露。我是没有想到有这种解决思路，而且其中的操作符重载，也是第一次用，虽然不建议直接操纵原始内存，但是管窥门径还是挺有必要的，起码多少心里有点数。

实验的总体思想是这个样子：在对象在堆上创建的时候（一般都是用`new`），增加一个额外的簿记工作，实现里使用的是双向链表，记录内存分配情况，释放的时候从该链表里拿出对应的内存，释放掉，最后计算链表是否为空，如果不为空，说明有申请的内存没有被释放。思路清楚，相当于在内存管理的时候，增加了一个间接层，在不影响原有工作的情况下，多了一些记录的工作。

虽然看起来不复杂，细节还是有很多的。比如说，怎么注入我们自己的间接层，对象创建不归我们管啊？其实`new`一个对象，是分为两个动作，第一步，利用`operator new`(和`new`不是一个东西)分配空间，相当于把冰箱打开，第二步，调用对象的构造函数，在裸内存上构建对象，相当于把大象放进去。`new`操作符是不能重载的，但是，但是`operator new`是可以的，这也就是我们注入代码的地方。重载的时候有一些注意事项：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190612153518.png)

下面就可以看代码了。

#### Goal

- 实现一个简单的内存泄露检测器，能够打印出内存泄露的情况

#### Environment

- OS： ubuntu 18.04 (64 bit)
- Compiler: g++ 7.3.0

#### Step

#####　1. 实现

先写个测试程序，

```c++
class Error
{
public:
    Error(int n)
    {
        if (n <= 0)
        {
            throw 1000;
        }
        _data = new int[n];
    }
    ~Error()
    {
        delete[] _data;
    }
private:
    int *_data;
};

int main()
{
    int *a = new int[5];
    int *b = new int;   // forget delete
    delete b;

    try 
    {
        Error *e = new Error(0);    // throw error, past nextline, memroy leak
        delete e;
    }
    catch (int &ex)
    {
        std::cout << "Exceptrion catch: " << ex << std::endl;
    }
}
```

人肉内存泄露检测器告诉我们，有两处内存泄露，一个是`int *a`，忘记`delete`，另一个是`Error *e`，因此被异常中断，`delete`并不会被执行。

开始写检测器。

头文件就只有一个类，

```c++
// operator new 重载
void *operator new(size_t _size, char *_file, unsigned int _line);
void *operator new[](size_t _size, char *_file, unsigned int _line);

// 增加文件和行信息
#ifndef __NEW_OVERLOAD_IMPLEMENTATION_
#define new new(__FILE__, __LINE__)
#endif 

class leak_detector
{
public:
    static unsigned int _callCount;  // 确保LeakDetector()只调用一次
    leak_detector() noexcept
    {
        ++_callCount;
    }
    ~leak_detector() noexcept
    {
        if (--_callCount == 0)
        {
            LeakDetector();
        }
    }  
private:
    static unsigned int LeakDetector() noexcept;
};

// 全局静态变量，程序退出的时候析构，完成检测
static leak_detector _exit_counter;
```

有个内部静态函数，还有一个静态计数器，这是为了防止`LeakDetector()`函数被调用多次。定义了一个静态对象，我们知道静态变量的生存期是全局的，因此程序结束，该变量会析构，在析构函数中，我们完成内存泄露的检测，很漂亮。

至于上面的条件编译，是为了注入`__FILE__`和`__LINE__`信息，帮助我们准确定位内存泄露的位置。

刚才已经说了，我们需要一个双向链表做一些簿记工作，

```c++
/ 内存管理链表
struct MemoryList 
{
    struct MemoryList *_next, *_prev;
    size_t _size;    // 申请内存大小
    bool _isArray;   // 是否是数组
    char *_file;     // 存储所在文件
    unsigned int _line;  // 存储所在行
};

static unsigned long _memory_allocated = 0; // 分配内存大小
MemoryList _root = {&_root, &_root, 0, false, nullptr, 0};  // 空节点

// 类内静态成员类外定义
unsigned int leak_detector::_callCount = 0;

```

不要忘了在类外定义静态成员变量，同时这里定义了一个记录内存分配情况的变量以及头结点。

```c++
// 分配内存
void *AllocateMemory(size_t size, bool isArray, char * file = nullptr, unsigned line = 0)
{
    // 分配需要空间和一个MemoryList节点
    size_t newSize = sizeof(MemoryList) + size;

    // operator new被重载，只能用malloc
    MemoryList *newElem = static_cast<MemoryList *>(malloc(newSize));
    newElem->_next = _root._next;
    newElem->_prev = &_root;
    newElem->_size = size;
    newElem->_isArray = isArray;
    
    if (file)
    {
        newElem->_file = static_cast<char *>(malloc(strlen(file) + 1));
        strcpy(newElem->_file, file);
    }

    newElem->_line = line;

    // update list
    _root._next->_prev = newElem;
    _root._next = newElem;

    // 记录
    _memory_allocated += size;
    
    // 返回分配空间的起始指针
    return reinterpret_cast<char *>(newElem) + sizeof(MemoryList);
}

void DeleteMemory(void *ptr, bool isArray)
{
    // 回到起始位置
    MemoryList *curElem = reinterpret_cast<MemoryList *>(static_cast<char *>(ptr) - sizeof(MemoryList));

    if (curElem->_isArray != isArray)
    {
        // error
        return;
    }

    // update
    curElem->_prev->_next = curElem->_next;
    curElem->_next->_prev = curElem->_prev;
    _memory_allocated -= curElem->_size;

    // malloc for file
    if (curElem->_file)
    {
        free(curElem->_file);
    }
    free(curElem);
}
```

内存分配和释放，我们需要引入自己的一些额外操作，其实就是在分配内存的时候，多分配一个节点大小的内存空间，附着在欲分配内存的头部，存储该段内存的某些信息。在释放内存的时候，也要连带着将这个节点的内存空间释放。在操作节点的时候不要忘记更新双向链表的指向。

```c++
// 重载操作符
void *operator new(size_t size)
{
    return AllocateMemory(size, false);
}

void *operator new[](size_t size)
{
    return AllocateMemory(size, true);
}

void *operator new(size_t size, char *file, unsigned int line)
{
    return AllocateMemory(size, false, file, line);
}

void *operator new[](size_t size, char *file, unsigned int line)
{
    return AllocateMemory(size, true, file, line);
}

void operator delete(void *ptr) noexcept
{
    DeleteMemory(ptr, false);
}

void operator delete[](void *ptr) noexcept
{
    DeleteMemory(ptr, true);
}
```

重载操作符比较直接，就是内部使用我们的分配器和释放器。

最后的最后，我们就需要统计了。

```c++
// last check
unsigned int leak_detector::LeakDetector() noexcept 
{
    unsigned int count = 0;
    MemoryList *ptr = _root._next;
    // 遍历链表
    while (ptr && ptr != &_root)
    {
        if (ptr->_isArray)
        {
            std::cout << "leak[] ";
        }
        else 
        {
            std::cout << "leak   ";
        }
        std::cout << ptr << " size " << ptr->_size;
        if (ptr->_file)
        {
            std::cout << " (locate in " << ptr->_file << " line " << ptr->_line << ")";
        }
        else 
        {
            std::cout << " (cannot find position)";
        }
        std::cout << std::endl;

        ++count;
        ptr = ptr->_next;
    }   

    if (count)
    {
        std::cout << "Total " << count << " leaks, size " << _memory_allocated << " byte " << std::endl;
    }
    
    return count;
}

```

说白了其实就是个链表遍历的过程，如果遇到非空节点，因为该段内存的空间我们都有，因此统计就很容易。最后输出即可。

##### 2. 测试结果

测试结果如下：

![](https://raw.githubusercontent.com/plantree/PictureBed/master/images/20190612154654.png)

相关代码都在这里[Github](https://github.com/plantree/Practice)

#### Thinking：

一个简单的内存泄露检测器，很有意思的练手项目，不复杂，而且确实能用。更主要的是，是设计的思路，以及选择的实现手段，的确，工具都是现成的，都摆在那里，但是有的人就知道怎么用，选择何种方式，解决面临的问题，像我就难得想出来这种思路。而且我们平时在使用一些工具的时候，倒不是说一定要对内部机理有多么深刻的洞察，但起码要有一些想法，尝试着探索。想法未必需要很多，有的话就试着落实一下，有些概念，不亲自做一做，理解的就不够深刻。

#### Reference：

- 《C++ Primer》

- https://www.shiyanlou.com/courses/657/labs/2130/document/

- https://www.cnblogs.com/luxiaoxun/archive/2012/08/10/2631812.html

  