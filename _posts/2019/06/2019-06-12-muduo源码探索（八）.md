---
layout: post
title: muduo源码探索 (八)
categories: [muduo]
description: muduo源码探索-Singleton/ThreadLocalSingleton
keywords: muduo, network, 网络
---

自己之前看过设计模式，不过基本忘得差不多了，要说哪一种设计模式记得最清楚，那毫无疑问是`Singleton`单例模式。这种设计模式的目的，是

> 想在整个系统中只存在一个类的实例

这种唯一性，不仅节省内存空间，而且在某些场景下有着某种必要性，比如记录系统全局状态的一个记录器，等等。有，且只有一个，就够了。

单例模式本身不复杂，但是考虑到多线程场景，就需要一些额外的考虑了。

另外一个，其实和单例模式有点关系，`ThreadLocalSingleton`，线程局部单例，怎么理解？可以理解为线程局部数据中的一个单例对象，也就是每个线程都有各自的一份单例对象。测试的时候，对于单例模式，还使用了`ThreadLocal`作为单例内部的存储数据，这个与刚才那个有所不同，全局只有一个单例对象实例，但是这个单例对象的内部，存储的是线程局部数据，每个线程所看到的，是不一样的。

#### Singleton

##### 1. 任务

- 实现多线程安全的单例模式

##### 2. 实现

普通版本的单例模式，内部有个静态的成员变量，这样就能保证全局的唯一性，但是多线程环境，静态成员变量的初始化，会面临竞争的风险，因此这里借助`pthread_once`，保证只会建立一次。

```c++
template <typename T>
class Singleton : noncopyable
{
public:
    // 不能在栈上construct
    Singleton() = delete;
    ~Singleton() = delete;
    static T &instance()
    {
        pthread_once(&ponce_, &Singleton::init);    // only init once
        assert(value_ != nullptr);
        return *value_;
    }

private:
    static void init()
    {
        value_ = new T();
        ::atexit(destroy);  // 注册析构时的行为
    }

    static void destroy()
    {
        // 不完全类型检测, no-need，new的时候就会出错
        //typedef char T_must_be_complete_type[sizeof(T) == 0 ? -1 : 1];
        //T_must_be_complete_type dummy; (void)dummy;

        delete value_;
        value_ = nullptr;
    }

    static pthread_once_t ponce_;
    static T *value_;
};
```

`init()`里的`atexit()`函数注册了单例对象销毁时的行为，因为上面的构造函数和析构函数都标记为删除，这是因为`Singleton`类的使用方式，是以类的方式，访问`intance()`静态成员函数，而不是新建一个对象。因此需要注册析构时的行为。其实有更简单的写法，

```c++
static Ｔ＆instance()
{
    static T value_;
    return value_;
}
```

这种做法在C++11语义下是有保证的：

> If multiple threads attempt to initialize the same static local variable concurrently, the initialization occurs exactly once (similar behavior can be obtained for arbitrary functions with [std::call_once](https://en.cppreference.com/w/cpp/thread/call_once)).

不会有多线程竞争的问题。

#### ThreadLocalSingleton

##### 1. 任务

- 实现线程局部数据单例模式，也就是每个线程内部只有一个单例对象存在

##### 2. 实现

```c++
template <typename T>
class ThreadLocalSingleton : noncopyable
{
public:
    // 禁止在栈上建立
    ThreadLocalSingleton() = delete;
    ~ThreadLocalSingleton() = delete;

    // 每个线程获取的实例都是各自私有的
    static T &instance()
    {
        if (!t_value_)
        {
            t_value_ = new T();
            deleter_.set(t_value_);
        }
        return *t_value_;
    }

    static T *pointer()
    {
        return t_value_;
    }

private:
    // 类共享删除器
    static void destructor(void *obj)
    {
        assert(static_cast<T *>(obj) == t_value_);
        delete t_value_;
        t_value_ = nullptr;
    }

    // 内部类
    class Deleter 
    {
    public:
        Deleter()
        {
            pthread_key_create(&pkey_, &ThreadLocalSingleton::destructor);
        }
        ~Deleter()
        {
            pthread_key_delete(pkey_);
        }
        void set(T *newObj)
        {
            assert(pthread_getspecific(pkey_) == nullptr);
            pthread_setspecific(pkey_, newObj);
        }
        pthread_key_t pkey_;
    };
    static __thread T *t_value_;    // 线程局部数据
    static Deleter deleter_;        // 类共享删除器
};
```

对于线程局部数据而言，当然少不了`__thread`关键字，因为这个值又是线程内部共享的，因此是`static`的。内部实现了`Deleter`删除器，而且是所有线程共享的，其中使用到了线程特定数据，刚开始不理解为什么，其实这个类的作用，是为了删除每个线程私有的那个值，因为析构函数是删除的，因此要手动处理资源释放的问题，上面的单例模式使用了`atexit()`注册了析构时的行为，这里是不可以的，为什么？因为那个只是在主线程中才被调用，其他线程的私有数据就丢失了。因此要使用一个间接层`Deleter`，借助线程特定数据，将线程私有的值存储起来，同时注册了析构时的行为，当程序推出的时候，`Deleter`会被析构，到时候自然会执行相应的行为。巧妙！

代码可见[Github](https://github.com/plantree/Slack)

#### 思考

单例模式，很常见，看起来不负责，但是到了多线程环境下，立马变得棘手，而且因为多线程调度不确定，因此就需要一些额外的同步策略。多线程是个利器，但是使用不好也会伤到自己。线程局部存储和线程特定数据是很好的工具，但是如果缺乏深入的了解，是很难用好的。

#### 参考：

- https://coolshell.cn/articles/265.html
- https://www.zhihu.com/question/264601551/answer/283819988
- https://en.cppreference.com/w/cpp/language/storage_duration
- 《Linux/Unix系统编程手册》
- 《Linux多线程服务端编程》


